//***************************************************************************
//
// Module      : DCon2010_M.c               ==>     DCon2010 - M E A S U R E
//
// Author      : Reiner Beh
// Date        : 01.07.11
// Last update : 05.12.12
// This update : 06.12.12
//
// Description : Hauptprogramm für DCon2010 - M E A S U R E
//               ==>  Mess-Controller  ==>
//               - dsPIC33FJ64GP802-E/MM
//
// Remarks     :
//
// Functions   :
//
// - main()                                                         09.10.12
// - CheckResetConditions()                                         01.09.11
// - DoResetActivities()                                            22.02.12
// - SM_Board_DCon2010()                                            26.09.12
// - DoCyclicActivities()                                           06.12.12
//
//***************************************************************************


//>==========================================================================
#ifdef USE_CPU_33FJ64GP802  //==============================================
//>==========================================================================
#define __dsPIC33FJ64GP802__
//<==========================================================================
#endif  // #ifdef USE_CPU_33FJ64GP802
//<==========================================================================
/*
//>==========================================================================
#ifdef USE_CPU_33FJ128GP804  //==============================================
//>==========================================================================
#define __dsPIC33FJ128GP804__
//<==========================================================================
#endif  // #ifdef USE_CPU_33FJ128GP804
//<==========================================================================
*/

#include <dsp.h>

#include "UART2.h"


#include "Definitions.h"
#include "Externals.h"

#include "Common.h"
#include "Utilities.h"

#include "DCon2010_M.h"


//>==========================================================================
// Prototypes of Main.c
//>==========================================================================


//>==========================================================================
// G O B A L S
//>==========================================================================
struct st_Test stTest;
//struct st_Misc stMisc;
struct st_ZeroDetection stZeroDetection;
struct st_SafetyData stSafetyData;
struct st_Config stConfig;
struct st_System stSystem;
//struct st_System stSystem __attribute__ ( (__section__(".xbss")) );


/*
//###########################################################################
// div. Speicher-Modelle ...
//###########################################################################

unsigned int uiStopPoint __attribute__ ((section (".ybss, bss, ymemory"))) = 0;
fractional fracValue __attribute__ ((section (".ybss, bss, ymemory"))) = Q15(0.0);

//REAL rTest_Curr_Val[PID_SAMPLES_CURR_MAX];
//REAL rTest_Curr_Val[PID_SAMPLES_CURR_MAX] __attribute__ ( (__section__(".aspace")) );  // ==> HEAP        ==>  512 Bytes
//REAL rTest_Curr_Val[PID_SAMPLES_CURR_MAX] __attribute__ ( (__section__(".ybss")) );    // ==> Y-DATA NEAR ==> 2400 Bytes
//REAL rTest_Curr_Val[PID_SAMPLES_CURR_MAX] __attribute__ ( (__section__(".xbss")) );    // ==> X-DATA NEAR ==> 2400 Bytes


// Typically, the input signal to an FFT
// routine is a complex array containing samples of an input signal.
// For this example, we will provide the input signal in an array declared in Y-data space.
fractcomplex sigCmpx[FFT_BLOCK_LENGTH] __attribute__ ((section (".ydata, data, ymemory"), aligned (FFT_BLOCK_LENGTH * 2 *2)));



#ifndef FFTTWIDCOEFFS_IN_PROGMEM
// Declare Twiddle Factor array in X-space
fractcomplex twiddleFactors[FFT_BLOCK_LENGTH/2] __attribute__ ((section (".xbss, bss, xmemory"), aligned (FFT_BLOCK_LENGTH*2)));
#else
// Twiddle Factor array in Program memory
extern const fractcomplex twiddleFactors[FFT_BLOCK_LENGTH/2] __attribute__ ((space(auto_psv), aligned (FFT_BLOCK_LENGTH*2)));
#endif

#ifdef FFTTWIDCOEFFS_IN_PROGMEM
        const fractcomplex twiddleFactors[] __attribute__ ((space(auto_psv), aligned (FFT_BLOCK_LENGTH*2)))=
        {
        0x7FFF, 0x0000, 0x7F62, 0xF374, 0x7D8A, 0xE707, 0x7A7D, 0xDAD8,
        0x7642, 0xCF04, 0x70E3, 0xC3A9, 0x6A6E, 0xB8E3, 0x62F2, 0xAECC,
        0x5A82, 0xA57E, 0x5134, 0x9D0E, 0x471D, 0x9592, 0x3C57, 0x8F1D,
        0x30FC, 0x89BE, 0x2528, 0x8583, 0x18F9, 0x8276, 0x0C8C, 0x809E,
        0x0000, 0x8000, 0xF374, 0x809E, 0xE707, 0x8276, 0xDAD8, 0x8583,
        0xCF04, 0x89BE, 0xC3A9, 0x8F1D, 0xB8E3, 0x9592, 0xAECC, 0x9D0E,
        0xA57D, 0xA57D, 0x9D0E, 0xAECC, 0x9592, 0xB8E3, 0x8F1D, 0xC3A9,
        0x89BE, 0xCF04, 0x8583, 0xDAD8, 0x8276, 0xE707, 0x809E, 0xF374
        } ;
#endif

//###########################################################################
//###########################################################################
*/


//==========================================================================
// SYSTEM-MACROS ... zur Initialisierung der CPU ...
// anstelle der Einstellungen in der IDE (Configure > Configuration Bits ...)
// s. p33FJ64GP802.h
//==========================================================================

// MIPS = (FOSC * PLLx) / 4      ==>     4 ClockCycles per instruction    ??????????????

// ===================================================
// Device configuration register macros for building the hex file
// ===================================================

// ===================================================
// FBS (0xF80000)
// ===================================================
/*
**   Boot Segment Data Ram:
**     RBS_LARGE_RAM                      Large Sized Boot Ram
**     RBS_MEDIUM_RAM                     Medium Sized Boot Ram 
**     RBS_SMALL_RAM                      Small Sized Boot Ram
**     RBS_NO_RAM                         No Boot Ram
**
**   Boot Segment Program Memory:
**     BSS_HIGH_LARGE_BOOT_CODE           High Security Lar Boot Flash 
**     BSS_LARGE_FLASH_HIGH               High Security Lar Boot Flash 
**     BSS_HIGH_MEDIUM_BOOT_CODE          High Security Med Boot Flash 
**     BSS_MEDIUM_FLASH_HIGH              High Security Med Boot Flash 
**     BSS_HIGH_SMALL_BOOT_CODE           High Security Small Boot Flash 
**     BSS_SMALL_FLASH_HIGH               High Security Small Boot Flash 
**     BSS_LARGE_FLASH_STD                Standard Security Lar Boot Flash 
**     BSS_STRD_LARGE_BOOT_CODE           Standard Security Lar Boot Flash 
**     BSS_MEDIUM_FLASH_STD               Standard Security Med Boot Flash 
**     BSS_STRD_MEDIUM_BOOT_CODE          Standard Security Med Boot Flash 
**     BSS_SMALL_FLASH_STD                Standard Security Small Boot Flash
**     BSS_STRD_SMALL_BOOT_CODE           Standard Security Small Boot Flash
**     BSS_NO_BOOT_CODE                   No Boot Segment Program Memory
**     BSS_NO_FLASH                       No Boot Segment Program Memory
**
**    Write Protect :
**     BWRP_WRPROTECT_ON                  Enabled 
**     BWRP_WRPROTECT_OFF                 Disabled 
*/
_FBS(RBS_NO_RAM & BSS_NO_BOOT_CODE & BWRP_WRPROTECT_OFF);


// ===================================================
// FSS (0xF80002)
// ===================================================
/*
**   Secure Segment Data Ram:
**     RSS_LARGE_RAM                      Large Sized Secure Ram 
**     RSS_MEDIUM_RAM                     Medium Sized Secure Ram 
**     RSS_SMALL_RAM                      Small Sized Secure Ram 
**     RSS_NO_RAM                         No Secure Ram
**
**   Secure Segment Program Memory:
**     SSS_LARGE_FLASH_HIGH               High Security Lar Secure Flash 
**     SSS_MEDIUM_FLASH_HIGH              High Security Med Secure Flash 
**     SSS_SMALL_FLASH_HIGH               High Security Small Secure Flash 
**     SSS_LARGE_FLASH_STD                Standard Security Large Secure Flash 
**     SSS_MEDIUM_FLASH_STD               Standard Security Med Secure Flash 
**     SSS_SMALL_FLASH_STD                Standard Security Small Secure Flash
**     SSS_NO_FLASH                       No Secure Segment
**
**    Write Protect :
**     SWRP_WRPROTECT_ON                  Enabled 
**     SWRP_WRPROTECT_OFF                 Disabled 
*/
_FSS(RSS_NO_RAM & SSS_NO_FLASH & SWRP_WRPROTECT_OFF);


// ===================================================
// FGS (0xF80004)
// ===================================================
/*
**   Code Protect:
**     GSS_HIGH                           high security protect on 
**     GSS_STD                            standard security code protect on 
**     GSS_OFF                            code protect off
**
**   Code Protect:
**     GCP_ON                             Enabled
**     GCP_OFF                            Disabled
**
**   Write Protect:
**     GWRP_ON                            Enabled
**     GWRP_OFF                           Disabled
**
*/
_FGS(GSS_OFF & GCP_OFF & GWRP_OFF);


// ===================================================
// _FOSCSEL (0xF80006)
// ===================================================
/*
**   Oscillator Source Selection:
**     FNOSC_FRC                          Fast RC oscillator
**     FNOSC_FRCPLL                       Fast RC oscillator w/ divide and PLL
**     FNOSC_PRI                          Primary oscillator (XT, HS, EC)
**     FNOSC_PRIPLL                       Primary oscillator (XT, HS, EC) w/ PLL
**     FNOSC_SOSC                         Secondary oscillator
**     FNOSC_LPRC                         Low power RC oscillator
**     FNOSC_FRCDIV16                     Fast RC oscillator w/ divide by 16
**     FNOSC_LPRCDIVN                     Low power Fast RC oscillator w/divide by N
**
**   Two-speed Oscillator Startup :
**     IESO_OFF                           Disabled
**     IESO_ON                            Enabled
*/
#ifdef CPU_TAKT_EXTERN_PLL                // externer Quarz 10 MHz mit PLL
_FOSCSEL(FNOSC_PRIPLL);          // extern ==> OSZ = 10,00 MHz; per PLL 40 MHz
#endif  // CPU_TAKT_EXTERN_PLL

#ifdef CPU_TAKT_INTERN_PLL                // interner Takt 7,37 MHz mit PLL
_FOSCSEL(FNOSC_FRCPLL);          // intern ==> OSZ = 7,37 MHz; per PLL  xx MHz
#endif  // CPU_TAKT_INTERN_PLL

#ifdef CPU_TAKT_INTERNSTART_EXTERN_PLL    // STARTEN mit internem Takt 7,37 MHz, danach NORMAL mit externem Quarz 10 MHz mit PLL
_FOSCSEL(FNOSC_FRC & IESO_OFF);  // intern ==> OSZ = 7,37 MHz
#endif  // CPU_TAKT_INTERNSTART_EXTERN_PLL


// ===================================================
// _FOSC (0xF80008)
// ===================================================
/*
**   Clock switching and clock monitor:
**     FCKSM_CSECME                       Both enabled
**     FCKSM_CSECMD                       Only clock switching enabled
**     FCKSM_CSDCMD                       Both disabled
**
**   Single configuration for remappable I/O:
**     IOL1WAY_OFF                        Disabled
**     IOL1WAY_ON                         Enabled
**
**   OSC2 Pin function:
**     OSCIOFNC_ON                        Digital I/O
**     OSCIOFNC_OFF                       OSC2 is clock O/P
**
**   Oscillator Selection:
**     POSCMD_EC                          External clock
**     POSCMD_XT                          XT oscillator
**     POSCMD_HS                          HS oscillator
**     POSCMD_NONE                        Primary disabled
*/
#ifdef CPU_TAKT_EXTERN_PLL                // externer Quarz 10 MHz mit PLL
//_FOSC(OSCIOFNC_OFF & POSCMD_XT);
_FOSC(FCKSM_CSDCMD & IOL1WAY_OFF & OSCIOFNC_OFF & POSCMD_XT);
#endif  // CPU_TAKT_EXTERN_PLL

#ifdef CPU_TAKT_INTERN_PLL                // interner Takt 7,37 MHz mit PLL
//_FOSC(OSCIOFNC_OFF & POSCMD_XT);
_FOSC(FCKSM_CSDCMD & IOL1WAY_OFF & OSCIOFNC_OFF & POSCMD_XT);
#endif  // CPU_TAKT_INTERN_PLL

#ifdef CPU_TAKT_INTERNSTART_EXTERN_PLL    // STARTEN mit internem Takt 7,37 MHz, danach NORMAL mit externem Quarz 10 MHz mit PLL
_FOSC(FCKSM_CSECMD & IOL1WAY_OFF & OSCIOFNC_OFF & POSCMD_XT);
#endif  // CPU_TAKT_INTERNSTART_EXTERN_PLL

// ===================================================
// _FWDT (0xF8000A)
// ===================================================
/*
**   LPRC = 32 kHz
**
**   Watchdog Timer:
**     FWDTEN_OFF                         Disabled
**     FWDTEN_ON                          Enabled
**
**   Windowed WDT:
**     WINDIS_ON                          Enabled
**     WINDIS_OFF                         Disabled
**
**   Watchdog prescaler:
**     WDTPRE_PR32                        1:32     ==>     1 ms
**     WDTPRE_PR128                       1:128    ==>                  4 ms
**
**   Watchdog postscaler:
**     WDTPOST_PS1                        1:1      ==>     1 ms  >>      4 ms
**     WDTPOST_PS2                        1:2      ==>     2 ms  >>      8 ms
**     WDTPOST_PS4                        1:4      ==>     4 ms  >>     16 ms
**     WDTPOST_PS8                        1:8      ==>     8 ms  >>     32 ms
**     WDTPOST_PS16                       1:16     ==>    16 ms  >>     64 ms
**     WDTPOST_PS32                       1:32     ==>    32 ms  >>    128 ms
**     WDTPOST_PS64                       1:64     ==>    64 ms  >>    256 ms
**     WDTPOST_PS128                      1:128    ==>   128 ms  >>    512 ms
**     WDTPOST_PS256                      1:256    ==>   256 ms  >>   1024 ms
**     WDTPOST_PS512                      1:512    ==>   512 ms  >>   2048 ms
**     WDTPOST_PS1024                     1:1024   ==>  1024 ms  >>   4096 ms
**     WDTPOST_PS2048                     1:2048   ==>  2048 ms  >>   8192 ms
**     WDTPOST_PS4096                     1:4096   ==>  4096 ms  >>  16384 ms
**     WDTPOST_PS8192                     1:8192   ==>  8192 ms  >>  32768 ms
**     WDTPOST_PS16384                    1:16384  ==> 16384 ms  >>  65536 ms
**     WDTPOST_PS32768                    1:32768  ==> 32768 ms  >> 131072 ms
*/
#ifdef WDT_ACTIVE
  // WatchdogTimer enabled
  // WD-Timeout : 2 ms                                 ==> CPU läuft nicht ...
//  _FWDT(FWDTEN_ON & WDTPRE_PR32 & WDTPOST_PS2);
  // WD-Timeout : 4 ms                                 ==> CPU läuft
//  _FWDT(FWDTEN_ON & WDTPRE_PR32 & WDTPOST_PS4);
  // WD-Timeout : 8 ms                                 ==> CPU läuft
//  _FWDT(FWDTEN_ON & WDTPRE_PR32 & WDTPOST_PS8);
  // WD-Timeout : 128 ms                               ==> CPU läuft
//  _FWDT(FWDTEN_ON & WDTPRE_PR32 & WDTPOST_PS128);
  // WD-Timeout : 256 ms                               ==> CPU läuft
  _FWDT(FWDTEN_ON & WDTPRE_PR32 & WDTPOST_PS256);
#else
  // WatchdogTimer disabled
  _FWDT(FWDTEN_OFF);
#endif  // WDT_ACTIVE


// ===================================================
// _FPOR (0xF8000C)
// Brown-Out : Reset bei Unterschreiten der Brown-Out-Spannung
// ===================================================
/*
**   Alternate I2C pins:
**     ALTI2C_ON                          I2C mapped to ASDA1/ASCL1
**     ALTI2C_OFF                         I2C mapped to SDA1/SCL1
**
**   Power-on Reset Value:
**     FPWRT_PWR1                         Disabled
**     FPWRT_PWR2                         2ms
**     FPWRT_PWR4                         4ms
**     FPWRT_PWR8                         8ms
**     FPWRT_PWR16                        16ms
**     FPWRT_PWR32                        32ms
**     FPWRT_PWR64                        64ms
**     FPWRT_PWR128                       128ms
*/
_FPOR(ALTI2C_OFF & FPWRT_PWR1);


// ===================================================
// FICD (0xF8000E)
// ===================================================
/*
**   JTAG Enable Bit:
**     JTAGEN_OFF                         JTAG is disabled
**     JTAGEN_ON                          JTAG is enabled
**
**   ICD communication channel select bits:
**     ICS_NONE                           Reserved
**     ICS_PGD3                           communicate on PGC3/EMUC3 and PGD3/EMUD3
**     ICS_PGD2                           communicate on PGC2/EMUC2 and PGD2/EMUD2
**     ICS_PGD1                           communicate on PGC1/EMUC1 and PGD1/EMUD1
*/
_FICD(JTAGEN_OFF & ICS_PGD1);


// ===================================================
// FUID0 (0xf80010)
// FUID1 (0xf80012)
// FUID2 (0xf80014)
// FUID3 (0xf80016)
// ===================================================
//_FUID0( OPT1_ON & OPT2_OFF & OPT3_PLL )
//_FUID1( OPT1_ON & OPT2_OFF & OPT3_PLL )
//_FUID2( OPT1_ON & OPT2_OFF & OPT3_PLL )
//_FUID3( OPT1_ON & OPT2_OFF & OPT3_PLL )



//===========================================================================
//
// Function    : main
//
// Date        : 01.07.11
// Last update : 08.10.12
// This update : 09.10.12
//
// Description : main-function of project DCon2010   < M E A S U R E >
//
// Input       :
//
// Output      :
//
// Return      :
//
//===========================================================================
int main(void)
{

  stSystem.uiLEDerrState = 0;


/*
 if ( (RCON & 0x4000) == 0x4000) {
  // IOPUWR : 0x4000  ==>  Illegal Opcode occurred
  LED_Signal(LED_SIGNALTIME_OUTER, LED_SIGNALTIME_INNER, 11);  // TimeOuter, TimeInner, BlinkCounter

  // hier geht's nicht mehr weiter ...

}
*/

/*
 else if ( (RCON & 0x0010) == 0x0010) {
  // WDTO : 0x0010  ==>  Watchdog-Timeout occurred
  LED_Signal(LED_SIGNALTIME_OUTER, LED_SIGNALTIME_INNER, 12);  // TimeOuter, TimeInner, BlinkCounter

  // hier geht's nicht mehr weiter ...

}
*/

#ifdef WDT_ACTIVE
  ClrWdt();        // Reset WDT
#endif  // WDT_ACTIVE

  // Initialisierung CPU dsPIC33FJ64GP802
  Init_CPU_dsPIC33FJ64GP802();

#ifdef WDT_ACTIVE
    ClrWdt();        // Reset WDT
#endif  // WDT_ACTIVE


  // Aufruf StateMachine ...
  SM_Board_DCon2010();

}

//===========================================================================
//
// Function    : SM_Board_DCon2010
//
// Date        : 01.07.11
// Last update : 08.10.12
// This update : 07.12.12
//
// Description : StateMachine für Board DCon2010   < M E A S U R E >
//
// Input       :
//
// Output      :
//
// Return      :
//
//===========================================================================
void SM_Board_DCon2010(void)
{


// hier ist diese Warteschleife zwingend notwendig, bis CPU angelaufen ist ...
// ToDo... in Init_CPU_dsPIC33FJ64GP802() ist zu untersuchen,
// wieso => while(OSCCONbits.LOCK!=1); 
// diesen Umstand nicht erfüllt ???
// Warten bis CPU angelaufen -> Takt ...
// Wartezeit muss etwas länger sein, als bei SLAVE :
// SLAVE   : 10, 20000
// MEASURE : 50, 20000
//LED_ToggleAndWait((unsigned long)500, (unsigned long)20000);  // ==> funktioniert !!!


#ifdef WDT_ACTIVE
#ifdef WDT_TEST
  stTest.uiWDT_TimeCnt = 0;
#endif  // WDT_TEST
#endif  // WDT_ACTIVE


  stSystem.ucKeepAlive = (unsigned char)0;

  stSystem.uiError = ERR_NONE;
  stSystem.uiInit = INIT_M_NONE;
  stSystem.ucMode = MODE_RESET;
  stSystem.ucState = STATE_RESET;
  stSystem.ucStateBackup = stSystem.ucState;
  stSystem.ucState_Past = stSystem.ucState;
  stSystem.uiErrorTimer = 0;
  stSystem.uiErrorHaltTimer = 0;

  stSystem.ucState = 0;
  stSystem.ucState = STATE_RESET;

  // LED ist "OFF"
  stSystem.uiLEDdspState = LED_TXD_MESS_OFF;


#ifdef TEST_LED_TXD_MESS_ACTIVE
  // ================================================================
  // Ausgang TXD_MESS für TEST-LED initialisieren
  // ================================================================
  TRISBbits.TRISB12 = 0;        // Output RB12: TEST-LED an TXD_MESS => Pin 20
#endif  // TEST_LED_TXD_MESS_ACTIVE


// TEST
//LED_ToggleTest();  // ACHTUNG !!!  ==>  PC bleibt hier drinnen ... while(1) ...



  // ======================================================================
  // Start StateMachine ...
  // ======================================================================
  while(1) {

#ifdef WDT_ACTIVE
    ClrWdt();        // Reset WDT
#endif  // WDT_ACTIVE

/*
The WDT flag, WDTO bit (RCON<4>), is not automatically
cleared following a WDT time-out. To detect subsequent
WDT events, the flag must be cleared in software.
*/

    switch (stSystem.ucState) {
      // ***************************************
      // SYSTEM_STATUS : STATE_RESET
      // ***************************************
      case STATE_RESET:  
          stSystem.ucMode = MODE_INIT;

          // Initialisierung Hardware
          Init_All();

          //> muss wieder rein ...
          // LED-Status für Initialisierungsphase ...
          //                stI2C_S.uiLEDcnts = 2;
          //                stI2C_S.uiLEDstateToDo |= LED_INITSTATE_16;
          //< muss wieder rein ...

        // Reset-Signal an SLAVE, dass MEASURE einen "Reset" durchgeführt hat ...
        Write_SlaveOutput_2(PER_CON_MESS_ON);    // PER_CON_MESS_2_R

/*
        if ( ( (stSystem.uiResetState & RESET_VREGS) == RESET_VREGS) ||
             ( (stSystem.uiResetState & RESET_SWR) == RESET_SWR) ||
             ( (stSystem.uiResetState & RESET_EXTR) == RESET_EXTR) ) {

          stUART1.stUART.ucTxStart = 1;

        }
*/


        stSystem.ucState = STATE_INIT;
        break;

      // ***************************************
      // SYSTEM_STATUS : STATE_INIT
      // ***************************************
      case STATE_INIT:  
        stSystem.ucMode = MODE_RUN;

        uibitUART1.Activ = BIT_TRUE;     // UART1 freigegeben ...

//        Sleep();    // SleepMode ...
        //> muss wieder rein ...
        // ZERO-DETECTION U/V/W/Current aktivieren ...
        //          stZeroDetection.uiState = ZERO_DET_ACTIVE;
        //< muss wieder rein ...

        stSystem.ucState = STATE_RUN;
        break;

      // ***************************************
      // SYSTEM_STATUS : STATE_RUN
      // ***************************************
      case STATE_RUN:  



        break;

      // ***************************************
      // SYSTEM_STATUS : STATE_ERROR
      // ***************************************
      case STATE_ERROR:  
        // Error reset -> mit State STOP wieder beginnen ... ?


        break;

      // ***************************************
      // SYSTEM_STATUS : STATE_MASTERERROR
      // ***************************************
      case STATE_MASTERERROR:  
        // Master-Error reset -> mit State STOP wieder beginnen ... ?


        break;

      // ***************************************
      // SYSTEM_STATUS : STATE_TEST
      // ***************************************
      case STATE_TEST:


        break;

      // ***************************************
      // SYSTEM_STATUS : default
      // ***************************************
      default:
//        SetErrorState(ERR_SYSTEM_SW_001);  // Error: SW: ungültiger SystemState
        // Check auf Durchführung eines SW- oder Error - Reset ?
//        CheckReset();
        break;

    }  // switch (stSystem.ucState)


    // Zyklische ToDo ...
    DoCyclicActivities();

    // Soll Software-Reset duchgeführt werden (vom SLAVE angefordert) ???
    CheckSwReset();


/*
//>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// WDT-TEST ...
//>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef WDT_TEST
  TimeDelay(10);          // let system reset ACHTUNG ! => T1 muss bereits laufen ...
                          // 10 * 40 ms =  400 ms
                          // 25 * 40 ms = 1000 ms
#endif  // WDT_TEST
//<+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// WDT-TEST ...
//<+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/


  }  // while(1)


  // nur bei Error ...
  while (1) {
    LED_ToggleAndWait((unsigned long)10, (unsigned long)10000);
  }


/*
//>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// WDT-TEST ...
//>+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
#ifdef WDT_ACTIVE
  ClrWdt();        // Reset WDT
#ifdef WDT_TEST
  stTest.uiWDT_TimeCnt = 0;
#endif  // WDT_TEST
#endif  // WDT_ACTIVE

#ifdef WDT_TEST
  InitTimer_1();          // Cycletime : 5 ms
#endif  // WDT_TEST

//<+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// WDT-TEST ...
//<+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
*/

}

//===========================================================================
//
// Function    : DoCyclicActivities
//
// Date        : 04.07.11
// Last update : 05.12.12
// This update : 06.12.12
//
// Description : Zyklische Aktivitäten ...
//
// Input       :
//
// Output      :
//
// Return      :
//
//===========================================================================
void DoCyclicActivities(void)
{
long lValue;
unsigned int *AdcValueU;
unsigned int *AdcValueV;
unsigned int *AdcValueW;
unsigned char CmdStr[50];
#ifdef ADC_PER_DMA

  if (stADC.uiProcess_DataValid == 1)
  {
      AdcValueU = stSamples[ADC_CHANNEL_IDX_PHU].puiSample_Start;
      AdcValueV = stSamples[ADC_CHANNEL_IDX_PHV].puiSample_Start;
      AdcValueW = stSamples[ADC_CHANNEL_IDX_PHW].puiSample_Start;

      sprintf(CmdStr, "U: %d\nV: %d\nW: %d\n", AdcValueU, AdcValueV, AdcValueW);
      UART2_SendString(CmdStr, strlen(CmdStr));

//    if (stADC.uiProcess_BufferNr == 0) {
      // Buffer gefüllt : uiADC_BufferA[] oder uiADC_BufferB[]

      // Phase-U
//      SelectSamples((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_PHU], ADC_CHANNEL_IDX_PHU, ADC_CHANNEL_NR_PHU);
//      // Phase-V
//      SelectSamples((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_PHV], ADC_CHANNEL_IDX_PHV, ADC_CHANNEL_NR_PHV);
//      // Phase-W
//      SelectSamples((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_PHW], ADC_CHANNEL_IDX_PHW, ADC_CHANNEL_NR_PHW);
//
//      // Laststrom ...
//      SelectSamples_CLV((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_CLV], ADC_CHANNEL_IDX_CLV, ADC_CHANNEL_NR_CLV);
//
//            // Mittelwert der Spannungen U/V/W berechnen für PID ...
//      lValue = (long)stActValue.iPhaseVal_Eff[ADC_CHANNEL_IDX_PHU] +
//               (long)stActValue.iPhaseVal_Eff[ADC_CHANNEL_IDX_PHV] +
//               (long)stActValue.iPhaseVal_Eff[ADC_CHANNEL_IDX_PHW] ;
//
//      stActValue.iPhaseVal_PH_UVW_Mean = (int)(lValue / 3l);


//    } else {
//      // Buffer gefüllt : uiADC_BufferB[]
//
//      SelectSamples((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_PHU], ADC_CHANNEL_IDX_PHU, ADC_CHANNEL_NR_PHU);
//      SelectSamples((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_PHV], ADC_CHANNEL_IDX_PHV, ADC_CHANNEL_NR_PHV);
//      SelectSamples((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_PHW], ADC_CHANNEL_IDX_PHW, ADC_CHANNEL_NR_PHW);
//      SelectSamples_CLV((struct st_Samples*)&stSamples[ADC_CHANNEL_IDX_CLV], ADC_CHANNEL_IDX_CLV, ADC_CHANNEL_NR_CLV);
//
//    }

    stADC.uiProcess_DataValid = 0;

  }  // if (stADC.uiProcess_DataValid == 1)

#endif  // ADC_PER_DMA


}

