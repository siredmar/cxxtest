//**********************************************************************************************
// Modulname: init	
//**********************************************************************************************
//
// Messumformer  - MUF
//
// Bearbeiter: Philipp Compensis
// Firma: HSS Barschat & Krönert GBR
// Tel.:  09129 28520
//
//
// init.c enthält sämmtliche Funktionen welche währende der Initalisierungsphase aufgerufen
// werden. Nicht enthalten sind Funktionen welche eindeutig einem anderen Modul zugeordnet sind
// (z.B. nicht SetEthernetInit).
// 
//**********************************************************************************************

//***************  Funktions-Prototypen  ***************************************
void GetConfigSchalter(void);
void SetConfigByteErzeugen(void);
void SetMessbereichIAC(void);
void GetParameterFuerModus2(void);
void SetParameterModus2Speichern();

//***************  INCLUDE-DATEIEN *******************************************

#include <intrinsics.h> // für __enable_interrupt()

#include "MUF.h"

#include "dcadc.h"
#include "eeprom.h"
#include "normierung.h"
#include "timer.h"
#include "LPC24xx_enet.h"
#include "profibus.h"
#include "ethernet.h"
#include "watchdog.h"
#include "spi.h"
#include "kalibrierung.h"
#include "filter.h"

extern struct MUF_SYSTEM muf_system;

/*******************************************************************************
* MainInit
* 
* Hauptinitalisierungsfunktion. Aus ihr werden u.a. semtliche Initalisieruntgs-
* funktionen aufgerufen.
*******************************************************************************/
void InitMain(void)
{    
    u8_t  debug = 0;
    u16_t abtastzeit_in_us;
    float abtastzeit_in_sec; // CAggou - v3.4 - 30.08.2013

    //Watchdog erstmal deaktivieren 
	SetDisableWatchdog();

	//Memory Accelerator Module (MAM) aktivieren (--> beschleunigt das Ausführen von Code vom Flash)
	MAMTIM = 4; //MAM fetch cycles are 4 CCLKs in duration
	MAMCR  = 0x2; //MAM functions fully enabled

    // Enable Fast GPIO0,1
    SCS |= SCS_GPIOM; // In SetHardwareInit
  
    // Init Test-Pins
	TESTPIN200_INIT();
	TESTPIN201_INIT();
	
	// Init Fehler-LED
	FEHLER_LED_INIT();		
	FEHLER_LED_OFF();

    // Init System-LED
    #ifdef HW_REV_4_0               //Erst ab HW Rev 4.0
        SYSTEM_LED_INIT();
        SYSTEM_LED_OFF();
    #endif  //#ifdef HW_REV_4_4

    //Init Systemflags setzen
    muf_system.ethernet_verbindungsaufbau_aktiv = FALSE;
    muf_system.kalibrierung_aktiv               = FALSE;
	
	//Einlesen der Konfiguration aus der Stellung des Drehschalters
	GetConfigSchalter();	//wichtig: vor SetEthernetInit() und SetProfibusInit() da dort u.a. der Modus ausgewertet wird

	//Initalisierung des EEPROMS
	SetEEPROMInit();

#ifdef MIT_PROFIBUS		
	InitProfibus();
#endif	

	//Kalibrierungswerte aus dem EEPROM auslesen und
	//Normierungswerte berechnen
	SetNormierungswerte();

    // Timer Initialisieren
	StartSystemTimer(Timer0IntrHandler, 10000); //10kHz

    // Interrupt Initialisieren

    ctl_global_interrupts_enable();
		
	//Ini der SPI-Schnittstelle für die ADCs
#ifndef DEBUG_SW_SPI	
	InitSPI();
#endif	

	//Initialisierung des Pins für das Conversion-Start-Siganl für den AC-ADC
	CONVST_PIN_INIT(); 

	//Interrupts aktivieren. (Vor InitEthernet da das ARP-Protokoll den Timer, und dieser den Timer-IRQ benötigt)
	__enable_interrupt();  
		
	//Initalisierung Ethernet
	InitEthernet();
	muf_system.ethernet_tx_enable = FALSE; //Wird erst nach dem ersten AC-ADC-IRQ aktiviert

    //Auselsen der MAC-Adresse aus dem EEPROM
    SetMACAddress();

	//Erzeugen des Konfigurations-Bytes welches mit jedem Datenframe mit übertragen wird
	SetConfigByteErzeugen();	

    //Parameter für den Berechnungsmodus aus dem EEPROM auslesen
    GetParameterFuerModus2();

    /*
    #warning Debug
    //muf_system.parameter_modus2.faktor_abtastzeit = 0; //0 --> 500us
    muf_system.parameter_modus2.faktor_abtastzeit = 1;
    muf_system.parameter_modus2.faktor_u = 1;
    muf_system.parameter_modus2.faktor_i = 1;
    */

    //Anschließend: Setzen der Abtastzeit mit der die Funktionen des Mathematik-Modusl aufgerufen werden
    abtastzeit_in_us = GET_ABTASTZEIT(muf_system.parameter_modus2.faktor_abtastzeit);
    SetTimePerTick(abtastzeit_in_us);
	
    // Berechnung der Abtastzeit in Sekunden CAggou - v3.4 - 30.08.2013
    abtastzeit_in_sec = (abtastzeit_in_us / 1000000.0f); 

    // Initialisierung der Grenzen des Rate-of-Change-Filters CAggou - v3.4 - 30.08.2013
    InitRateOfChangeFilter(abtastzeit_in_sec, muf_system.parameter_modus2.faktor_h);

#ifdef KALIBRIERUNGS_SW
    #ifndef KEIN_WATCHDOG
        #define KEIN_WATCHDOG
    #endif
#endif

#ifndef KEIN_WATCHDOG
    //Watchdog initalisieren und dadurch aktivieren:
    InitWatchdog();
#else
	#warning Watchdog ist deaktiviert!
#endif
}
/******************************************************************************/


/*******************************************************************************
* GetConfigSchalter
* 
* Funktion um die kodierte Stellung des Drehschalters einzulesen und das muf_system
* abhänig davon zu konfigurieren.
*******************************************************************************/
void GetConfigSchalter(void)
{
	u8_t s;
	
	//kodierte Stellung des Drehschalters einlesen
	s = DREHSCHALTER;

#ifndef MIT_ZWEI_PHASEN_BETRIEB

    //Ab Version 1.20
    if(s == 0 | s == 1 | s == 4 | s == 5 | s == 8 | s == 9)
        muf_system.messbereich.ac_strom = MESSBEREICH_1A;
	else
		muf_system.messbereich.ac_strom = MESSBEREICH_5A;

    if(s == 0 | s == 2 | s == 4 | s == 6 | s == 8 | s == 10)
        muf_system.messbereich.dc_strom = MESSBEREICH_0_20MA;
	else
		muf_system.messbereich.dc_strom = MESSBEREICH_4_20MA;

    if(s <= 3)
        muf_system.modus = MODUS2_OHNE_DEBUGDATEN;
    else if(s <= 7)
        muf_system.modus = MODUS2;
    else if(s <= 11)
        muf_system.modus = MODUS1;

    if(s > 11) //Ungültige Konfiguration
		muf_system.fehler.konfigurations_fehler = TRUE; 

#else //#ifdef MIT_ZWEI_PHASEN_BETRIEB
    //if(s == 0 | s == 1 | s == 4 | s == 5 | s == 8 | s == 9)
    if( s==0 | s==1 | s==4 | s==5 | s==8 | s==9 | s==12 | s==13 ) //V.3.1.2
        muf_system.messbereich.ac_strom = MESSBEREICH_1A;
	else
		muf_system.messbereich.ac_strom = MESSBEREICH_5A;

    //if(s == 0 | s == 2 | s == 4 | s == 6 | s == 8 | s == 10)
    if( s==0 | s==2 | s==4 | s==6 | s==8 | s==10 | s==12 | s==14 ) //V.3.1.2
        muf_system.messbereich.dc_strom = MESSBEREICH_0_20MA;
	else
		muf_system.messbereich.dc_strom = MESSBEREICH_4_20MA;

    if(s <= 3)
        muf_system.modus = MODUS2_OHNE_DEBUGDATEN;
    else if(s <= 7)
        muf_system.modus = MODUS2;
    else if(s <= 11)
        muf_system.modus = MODUS1;
    //V.3.1.2
    else if(s > 11)
        muf_system.modus = MODUS2_OHNE_DEBUGDATEN; // + 2phasig (neu ab V.3.1.2)

	muf_system.messsystem = MESSSYSTEM_3U_1I;

#endif //#ifndef MIT_ZWEI_PHASEN_BETRIEB #else
       
}
/*******************************************************************************
* ENDE GetConfigSchalter
*******************************************************************************/


/*******************************************************************************
* SetConfigByteErzeugen
* 
* Funktion zum Erzeugen des Konfigurations-Bytes welches mit den Messwerten mit
* übertragen wird.
*******************************************************************************/
void SetConfigByteErzeugen(void)
{
	u8_t config_byte;
	config_byte = 0;
	
	if(muf_system.messbereich.dc_strom == MESSBEREICH_4_20MA)
		config_byte |= 0x1; //Bit 0 -> 0: 0..20mA; 1: 4..20mA
	
	if(muf_system.messbereich.ac_strom == MESSBEREICH_5A)
		config_byte |= 0x2; //Bit 1 -> 0: 1A; 1: 5A
	
    /* Mit der SW-Erweiterung (2.0) entfallen
	if(muf_system.messbereich.ac_spannung == MESSBEREICH_110V)
		config_byte |= 0x4; //Bit 2...3 -> 00: 100V; 01: 110V; 11: 120V
	else if(muf_system.messbereich.ac_spannung == MESSBEREICH_120V)
		config_byte |= 0xC; //Bit 2...3 -> 00: 100V; 01: 110V; 11: 120V
    */

    //Neu mit der SW-Erweiterung (2.0)
    if(muf_system.modus == MODUS2)   //Modus 2
        config_byte |= 0x10;        //Bits 4...5 = 01 = Modu 2
    else if (muf_system.modus == MODUS2_OHNE_DEBUGDATEN)  //Modus 2
        //config_byte |= 0x20;        //Bits 4...5 = 01 = Modu n ohne Debugdaten
        config_byte |= 0x30;        //Bits 4...5 = 11 = Modu n ohne Debugdaten //PComp 03.04.2012
	
	//Kofigurationsbyte seten:
	SetConfigByteEthernet(config_byte);
    SetConfigByteProfibus(config_byte);
}
/*******************************************************************************
* ENDE SetConfigByteErzeugen
*******************************************************************************/


/*******************************************************************************
* GetParameterFuerModus2
* 
* Funktion um die Parameter für den Modus 2 ("Berechnungsmodus") aus dem EEPROM
* aus zu lesen
*
*******************************************************************************/
void GetParameterFuerModus2(void)
{
    BOOLEAN set_default_parameter = FALSE;
    BOOLEAN ret_val;

    BOOLEAN eth_link_status;
    u16_t i;

    //Gespeicherte Parameter aus dem EEPROM auslesen
    ret_val = GetEEPROMRead(PARAMETER_MODUS2_START_ADDRESS, (u8_t *)&muf_system.parameter_modus2, sizeof(struct PARAMETER_MODUS2_STRUCT));
    
    //Wenn nicht gelesen werden konnte
    if(ret_val == EEPROM_FEHLER)
    {
        set_default_parameter = TRUE; //Standard-Werte verwenden
    }
    else //Wenn Daten aus dem EEPROM ausgelesen wurden
    {
        //Wenn die Daten nicht gültig sind sind. (kommando wurde beim Speichern mit gespeichert.)
        if(muf_system.parameter_modus2.kommando != KOMMANDO_NEUE_PARAMETER)
        {
            set_default_parameter = TRUE; //Standard-Werte verwenden
        }
    }

    if(set_default_parameter == TRUE)
    {
        //Standard-Werte verwenden
        muf_system.parameter_modus2.faktor_i          = DEFAULT_PARAMETER_FAKTRO_I;
        muf_system.parameter_modus2.faktor_u          = DEFAULT_PARAMETER_FAKTOR_U;
        muf_system.parameter_modus2.faktor_abtastzeit = DEFAULT_PARAMETER_FAKTOR_ABTASTZEIT;
        muf_system.parameter_modus2.xq                = DEFAULT_PARAMETER_XQ;
        //muf_system.parameter_modus2.ta                = DEFAULT_PARAMETER_TA;         //v.3.3 22.02.2013
                                                                                        // Parameter entfallen
        muf_system.parameter_modus2.f0                = DEFAULT_PARAMETER_F0;
        muf_system.parameter_modus2.schwelle_skalarprodukt = DEFAULT_PARAMETER_SCHWELLE_SKALARPRODUKT;

        //v.3.3 entfallen:
        /*
        //TBD
        //Vers 2.3.1
        muf_system.parameter_modus2.b0 = DEFAULT_PARAMETER_B0;
        muf_system.parameter_modus2.b1 = DEFAULT_PARAMETER_B1;
        muf_system.parameter_modus2.b2 = DEFAULT_PARAMETER_B2;
        muf_system.parameter_modus2.a0 = DEFAULT_PARAMETER_A0;
        muf_system.parameter_modus2.a1 = DEFAULT_PARAMETER_A1;
        */
    }
}
/*******************************************************************************
* ENDE GetParameterFuerModus2
*******************************************************************************/
