//**********************************************************************************************
//
// Messumformer  - MUF
//
// Bearbeiter: Philipp Compensis
// Firma:      HSS Barschat & Krönert GBR
// Tel.:       09129 28520
//
//
// Der Messumformer wird in Kraftwerken eingesetzt und ist dort Teil eines Regelkreises.
// Er erfasst alle 100µs drei Spannungen und drei Ströme vom Generator und verendet diese mit
// dem nächten 100µs Takt via UDP über Ethernet. Zusätzlich werden noch alle 2ms zwei DC-Ströme
// und eine DC-Spannung erfasst und ebenfalls übermittelt. Alternativ zu Ethernetübertragung
// können die Messwerte per PROFIBUS abgefragt werden.
// 
// Diese Main.c-Datei beinhaltet die Hauptablaufsteuerung des Controllers.
//
// 
// ACHTUNG: Wenn von einer Version <= 3.0 aktualisiert wird, muss das Gerät neu kalibriert werden.
//          Z.B. Update von V.3.0 auf 3.1 --> Neukalibrierung notwendig
// 
// ACHTUNG: Alle Dateien müssen auf Optimization-Level 1 stehen!! Einzige Ausnahme ist die
//          Datei: "start_bootloader"!!!
//**********************************************************************************************

// Firmware-Varnaite NTG-3000-DiodeMonitor (Diodenausfallueberwachung)
#define MUF_VERSION     "NTG-3000-Diode Monitoring FW v1.1"

#undef HW_REV_1_1
#undef HW_REV_2_2       //V.3.0
#define HW_REV_4_0
// Aktuelle HW Rev. 5.1, jedoch keine Änderungen der SW gegenüber der Rev. 4.0

//********** Defines für neue Funktionen die erst mit der V.3.2 ausgeliefertwerden ***********
#define MIT_LIFEBIT
#define MIT_ZWEI_PHASEN_BETRIEB

// Die Kalibrierungs-SW ist eine extra Version (ab V.3.1.2) und nicht mehr Teil der ner Normalen SW
//#define KALIBRIERUNGS_SW // Umschaltung zwischen Kalibrierungs-SW und normaler SW/Firmware über define
// Die Umschaltung zwischen normaler FW, Kalibrierungs-SW und NTG-1000-Variante erfolgt über
// eigene Build-Varianten (Debug, Release, Kalibrierung Debug, Kalibrierung Release, NTG-1000 Release ...)

//*********** Defines für das Debugen ******************************************
//#define DEBUG_SINUS_GENERATOR
//#define I2_GLEICH_0     // Zum Testen des Betreibs mit nur 2 x I und 3 x U (MESSSYSTEM_3U_2I)
//#define DEBUG_DC_TEST
//#define DEBUG_EEPROM_PARAMETER_UEBER_ETHERNET_SENDEN
//#define DEBUG_EEPROM_FEHLER_UEBER_ETHERNET_SENDEN
//#define KEIN_WATCHDOG
//#define PROFIBUSFEHLER_NICHT_ZURUECKNEHMEN


//*****************************  Watchdog  ************************************
#define WATCHDOG_TIME_OUT	1000000		//in µs (min. 255)


//***********  Hardwarespezifische Includs  ************************************
#include <ctl_api.h>
#include <targets/LPC2000.h>

//***********  Datentypen ******************************************************

typedef unsigned short 	u16_t;
typedef unsigned char 	u8_t;
typedef unsigned long 	u32_t;
typedef long 			int32_t;
typedef unsigned int*   p_u32_t;
typedef short 			int16_t;
typedef char 			BOOLEAN;
typedef unsigned char   byte;

// CAggou - v3.4
//*************************  Defines fuer das Update 
typedef  void (*pFunction)(void);

#define  BOOTLOADER_UPDATE_START_SECTOR_ADDRESS    0x0000A000

enum eCOMM_ID
{
    //***************************************************************************************
    // Ethernet-Kommunikations-IDs:
    // Comm-ID's von 0 bis 5
    //***************************************************************************************
    COMM_ID_NAK = 0,
    COMM_ID_ACK = 1,

    //***************************************************************************************
    // Ethernet-Update-IDs:
    // Comm-ID's von 1000 bis 1999
    //***************************************************************************************
    COMM_ID_BEFEHL_FIRST                = 1000,
    COMM_ID_1000_UPDATE_START           = 1000,
    COMM_ID_1001_UPDATE_REQUEST         = 1001,
    COMM_ID_1002_UPDATE_OVERVIEW        = 1002,
    COMM_ID_1003_UPDATE_REQUEST_PACKAGE = 1003,
    COMM_ID_1004_UPDATE_SEND_PACKAGE    = 1004,
    COMM_ID_1005_UPDATE_COMPLETE        = 1005,
    COMM_ID_1006_UPDATE_SUCCESSFUL      = 1006,
    COMM_ID_1007_FW_VERSION_REQUEST     = 1007,
    COMM_ID_1008_FW_VERSION_RESPONS     = 1008,
    COMM_ID_BEFEHL_LAST                 = 1008,
    COMM_ID_BEFEHL_MAX                  = 1999,

    COMM_ID_ERROR_FIRST                 = 2000,
    COMM_ID_2000_ERROR_UPDATE           = 2000, // Fehler während des Updates
    COMM_ID_2001_ERROR_FIRMWARE         = 2001, // Fehlerhafte Checksumme der Firmware
    COMM_ID_2002_ERROR_LAST             = 2001,
    COMM_ID_ERROR_MAX                   = 2999,
};

//*****************************  MACROS ************************************
                                                  // Löschen der Bits des Parameters im Register und setzen auf einen neuen Wert
#define SET_REGISTER_BITS(reg, parameter, value)  reg &= ~parameter ## _MASK; \
                                                  reg |= parameter ## _MASK & (value << parameter ## _BIT)   
#define LongToBin(n) (((n >> 21) & 0x80) | \
                      ((n >> 18) & 0x40) | \
                      ((n >> 15) & 0x20) | \
                      ((n >> 12) & 0x10) | \
                      ((n >>  9) & 0x08) | \
                      ((n >>  6) & 0x04) | \
                      ((n >>  3) & 0x02) | \
                      ((n      ) & 0x01))
#define MAX_CALC(a, b) (((a) > (b)) ? (a) : (b))
#define MIN_CALC(a, b) (((a) < (b)) ? (a) : (b))
#define __BIN(n) LongToBin(0x##n##l)
#define BIN8(n)                       __BIN(n)
#define BIN(n)                        __BIN(n)
#define BIN16(b1,b2)        ((        __BIN(b1)  <<  8UL) + \
                                      __BIN(b2))
#define BIN32(b1,b2,b3,b4) ((((u32_t)__BIN(b1)) << 24UL) + \
                            (((u32_t)__BIN(b2)) << 16UL) + \
                            (((u32_t)__BIN(b3)) <<  8UL) + \
                              (u32_t)__BIN(b4))


//******************************************************************************


#ifndef FALSE
	#define FALSE 0
#endif

#ifndef TRUE
	#define TRUE  1
#endif


//*************** Strukturen ***************************************************

struct MESSBEREICH_STRUCT
{
	char ac_strom;
	char ac_spannung;
	char dc_strom;
} __attribute__((packed));

#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
struct MESSWERTE_STRUCT
{
	int16_t		u1;	 //1. AC-Spannung
	int16_t		u2;  //2. AC-Spannung
	int16_t		u3;  //3. AC-Spannung
	int16_t		i1;	 //1. AC-Strom
	int16_t		i2;  //2. AC-Strom
	int16_t		i3;  //3. AC-Strom
	u16_t		dc1; //1. DC-Signal (Strom)
	u16_t		dc2; //2. DC-Signal (Strom)
	u16_t		dc3; //3. DC-Signal (Spannung)
} __attribute__((packed));
#pragma pack()

#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
struct KALIBRIERUNG_STRUCT
{
	int16_t ac_werte[27]; // 3x +U, 3x +I(5A), 3x I(1A), 3x U0, 3x I0(5A), 3x I0(1A) 3x -U, 3x -I(5A), 3x -I(1A)
	
	u16_t	dc_werte[6];  // 3x DC+, 3x DC0
	//Prüfsumme
	u8_t checksum;
}__attribute__((packed));
#pragma pack()

// CAggou - v3.4
// Struktur, die in das interne SRAM gelegt wird, damit der zwischen der Firmware und dem Bootloader
// Informationen ausgetauscht werden können
struct BOOTLOADER_UPDATE_DATA
{
    // Stati
    u16_t update_daten_init_flag:1;
    u16_t update_daten_vorhanden:1;
    u16_t update_durchgefuehrt:1;
    u16_t update_fehler_flag:1;
    u16_t partitionen_auf_auslieferungszustand_setzen:1;
    u16_t partitionen_auf_auslieferungszustand_gesetzt:1;
    u16_t start_partitions_nummer:1; // 0 -> Partition 1 wurde gestartet; 1 -> Partition 2 wurde gestartet
    u16_t reserve:9;

    // ACHTUNG! Eine Änderung der Strukur-Größe erfordert eine Änderung der Sektion 
    // ".user_data" in flash_placement.xml!
    // Und es muss die gleichnamige Struktur im SecondaryBootloader angepasst werden
}__attribute__((packed));
//
//Defines für KALIBRIERUNG_STRUCT
//
#define AC_POS_U1 		 0
#define AC_POS_I1_5A	 3
#define AC_POS_I1_1A	 6
#define AC_NULL_U1		 9 
#define AC_NULL_I1_5A	12
#define AC_NULL_I1_1A	15
#define AC_NEG_U1		18
#define AC_NEG_I1_5A	21
#define AC_NEG_I1_1A	24

#define DC1_POS			 0
#define DC2_POS			 1
#define DC3_POS			 2
#define DC1_NULL		 3
#define DC2_NULL		 4
#define DC3_NULL		 5

#define MAX_AC           6
#define MAX_DC			 3

#define SIZEOF_CHECKSUM     (sizeof(u8_t))
#define SIZEOF_KOMPRIMIERT  ((sizeof(struct KALIBRIERUNG_STRUCT) - SIZEOF_CHECKSUM)  * 12 / 16)
//                                            Größe komprimiert     + Integer-Divisions-Anpassung + Checksummenbyte
#define SIZEOF_KALIBRIERUNGSWERTE_KOMPRIMIERT ((SIZEOF_KOMPRIMIERT) + (SIZEOF_KOMPRIMIERT % 2) + SIZEOF_CHECKSUM)
// Ab Version 3.0.1 werden die Kalibrierungsdaten komprimiert im EEPROM gespechert


//Defines für NORMIERUNG_STRUCT
#define M_AC_POS_U1		 0
#define M_AC_POS_I1_5A	 3
#define M_AC_POS_I1_1A	 6
#define M_AC_NEG_U1		 9
#define M_AC_NEG_I1_5A	12
#define M_AC_NEG_I1_1A	15
#define M_AC_NEG_I3_1A  17
#define M_AC_SIZE       18 //für 3x +U, 3x +I(5A), 3x I(1A), 3x -U, 3x -I(5A), 3x -I(1A)
#define M_DC_SIZE        3 // 3x DC

#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
struct NORMIERUNG_STRUCT
{
	float 	m_ac[M_AC_SIZE];
	
	float 	m_dc[M_DC_SIZE];  
}__attribute__((packed));
#pragma pack()

#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
struct PARAMETER_MODUS2_STRUCT
{
    u8_t  kommando;     // Zeigt z.B. beim Empfang via PROFIBUS an dass neue Parameter übernommen werden solen
    float faktor_i;     // Umrechnungsfaktor von den Spannungen an den AC-I-Eingängen des
                        // MUFs in die Tatsächlichen Spannungen der Anlage
    float faktor_u;     // Umrechnungsfaktor von den Spannungen an den AC-U-Eingängen des
                        // MUFs in die Tatsächlichen Spannungen der Anlage
    u8_t  faktor_abtastzeit;   // Auswahl der Abtastzeit mit der die Werte im Modus 2 berechnet
                               // und via Ethernet übertragen werden

    // Parameter für die Berechnung der kompensiereten Frequenz
    //float reserve1;     // vorher: float faktor_fcomp;                                    //v.3.3 22.02.2013
    float faktor_h;     // Trägheit der Synchronmaschine, wird für die Berechnung der       // CAggou - v.3.4  30.08.2013
                        // MIN/MAX-Werte für den Rate-of-Change-Filter benötigt, wird in 
                        // Sekunden angegeben;                                        

    float xq;           // Hauptinduktivitaet der Querachse in pu


    // Options-Byte
    u32_t eingangs_filter_deaktiviert:1;  // Bit zum deaktivieren des Filters für die Eingangssignale - CAggou - v3.43
    u32_t reserve2:31;                    // vorher: float ta; // Abtastzeit zur Berechung von fcomp          //v.3.3 22.02.2013

    float f0;                       // Nennfrequenz in Hz

    float schwelle_skalarprodukt;   // Unterschreitet der Betrag des Skalarprodukt bei Berechnung 
                                    // der kompensierten Frequenz diesen Schwellwert wird der 
                                    // letzte gültige fcomp-Wert übertragen und die BIT-Kennung 
                                    // fcomp_schwelle_unterschritten gesetzte

    //v3.3 22.02.2013 Stadt Filterparameter für fcomp_gefiltert und p_gefilter
    //                Paramater für jeweils die erste und zweite Filterstufe.
    // Paramater für die 1. Filterstufe:
    float f1_b0;
    float f1_b1;
    float f1_b2;
    float f1_a0;
    float f1_a1;
    // Paramater für die 2. Filterstufe:
    float f2_b0;
    float f2_b1;
    float f2_b2;
    float f2_a0;
    float f2_a1;
}__attribute__((packed));
#pragma pack()
//Defines für kommando im PARAMETER_MODUS2_STRUCT
#define KOMMANDO_NEUE_PARAMETER 0x5A
#define GET_ABTASTZEIT(faktor_abtastzeit) ((faktor_abtastzeit + 1) * 500) //(Faktor + 1) * 500us

#pragma pack(1) // pragma packfip, damit kein Alignment durchgeführt wird
struct FEHLER_STRUCT
{	
	BOOLEAN		PROFIBUS_fehler                             :1;	// 0
	BOOLEAN     spannungs_phasen_ausfall                    :1; // 1 - Zeigt an wenn eine der Spannungsphasen ausgefallen ist
                                                                //     (Summe der Spannungen != 0)
	BOOLEAN		erweiterter_spannungs_phasenausfall_fehler	:1;	// 2 - Zeigt an ob eine, zwei oder alle drei Phasen ausgefallen sind:
                                                                //     LOW: Phasenausfall, HIGH: Kein Phasenausfall
	BOOLEAN		EEPROM_fehler                               :1; // 3 - Zugriff auf das EEPROM ist gescheitert
	BOOLEAN		programm_fehler                             :1; // 4 - Fehler in der SW, ungültiger zustand usw.
	BOOLEAN		konfigurations_fehler                       :1; // 6 - Ungültige bzw. fehlerhafte Konfiguration. Z.B. Drehschalter in Stellung C, D, E, F
	BOOLEAN		feglerhafte_kalibrierungwerte               :1; // 6
	BOOLEAN		ethernet_fehler                             :1; // 7   Kann nicht erkannt werden und wird deshalb auch nicht gesetzt
}__attribute__((packed));
#pragma pack()

struct MUF_SYSTEM
{
	// System-Timer-flags
	BOOLEAN		main_timer_flag_100us;	// flag für den 100µs Timer
    BOOLEAN		main_timer_flag_500us;	// flag für den 100µs Timer
	BOOLEAN 	main_timer_flag_1ms;	// flag für den 1ms Timer
	BOOLEAN 	main_timer_flag_2ms;	// flag für den 1ms Timer
	BOOLEAN		main_timer_flag_10ms;	// flag für den 10ms Timer
	BOOLEAN		main_timer_flag_100ms;	// flag für den 100ms Timer
	BOOLEAN		main_timer_flag_1s;		// flag für 1s Timer
	
	// Sonstie System-flags
	BOOLEAN		ethernet_tx_enable;
    BOOLEAN		ethernet_verbindungsaufbau_aktiv;
    BOOLEAN     kalibrierung_aktiv;
	
	//Konfiguration
	struct 		MESSBEREICH_STRUCT  messbereich;

	//Messwerte
	struct 		MESSWERTE_STRUCT	ADC_werte;
    //struct 		MESSWERTE_STRUCT	mittelwerte;
	struct		MESSWERTE_STRUCT	normierte_werte;
	
	//Kalibrierungswerte für die Normierung
	struct		KALIBRIERUNG_STRUCT		kalibrierungswerte; //Die bei der Kalibrierung erfassetn Werte
	struct		NORMIERUNG_STRUCT		normierungswerte;  //Die aus den Kalibrierungswerten berechneten Werte für die Normierung
	
	//Modus
    u8_t        modus;  //Modus = 1: reiner Messmodus, Modus = 2: Berechungen von Ueff, Ieff, P, Q, ...

#ifdef MIT_ZWEI_PHASEN_BETRIEB
    // 2phasig/3phasig
    u8_t        messsystem;     //V.3.1.2
#endif

    // CAggou - v3.44
    u8_t        funktionsblock_1_aktiv;
    u8_t        funktionsblock_2_aktiv;
    u8_t        funktionsblock_3_aktiv;
    u8_t        funktionsblock_4_aktiv;
    
    //Testmodus
	u8_t		testmodus;

    //Über PROFIBIUS einstellbare Parameter für den Modus 2 ("Berechnungsmodus")
    struct      PARAMETER_MODUS2_STRUCT parameter_modus2;

	//Fehler
	union
	{
		u8_t				  fehler_byte;
		u8_t				  fehler_summe;
		struct	FEHLER_STRUCT fehler;
	};
	
	int16_t info;
};

//Defines für Modus
#define MODUS1                  1
#define MODUS2                  2
#define MODUS2_OHNE_DEBUGDATEN  3

#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
struct DATENFRAME_STRUCT
{
	int16_t		u1;	//1. AC-Spannung
	int16_t		u2; //2. AC-Spannung
	int16_t		u3; //3. AC-Spannung
	int16_t		i1;	//1. AC-Strom
	int16_t		i2; //2. AC-Strom
	int16_t		i3; //3. AC-Strom
	u16_t		dc1; //1. DC-Signal (Strom)
	u16_t		dc2; //2. DC-Signal (Strom)
	u16_t		dc3; //3. DC-Signal (Spannung)
	u8_t		konfigurations_byte;
	u8_t		fehler_byte;
	u16_t		info;               // Optionale Zusatzinformationen
}__attribute__((packed));
#pragma pack()  // pragma pack end 


#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
struct ALPHA_BETA_STRUCT {
    float       ia;      // alfa-Komponente, Strom
    float       ib;      // beta-Komponente, Strom
    float       ua;      // alfa-Komponente, Spannung

    float       ub;      // beta-Komponente, Spannung
}__attribute__((packed));
#pragma pack()  // pragma pack end

//Im Modus 2 wird ein anderer Datenframe als im Modus 1 via ethernet und PROFIBUS übertragen
#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
struct DATENFRAME_MODUS2_STRUCT
{
    float       i_eff;          // Effektivwert Strom
    float       u_eff;          // Effektivwert Spannung
    float       p;              // Effektivwert Wirkleistung
    u16_t		dc1;            //1. DC-Signal (Strom)
	u16_t		dc2;            //2. DC-Signal (Strom)
	u16_t		dc3;            //3. DC-Signal (Spannung)
    u8_t        konfigurations_byte;
    u8_t        fehler_byte;
    u16_t       info;           // Optionale Zusatzinformationen
    float       q;              // Effektivwert Blindleistung
    float       s;              // Effektivwert  Scheinleistung
    float       cosphi;         // Wirkfaktor
    float       f;              // Frequenz
    float       fcomp;          // Kompensierte Frequenz

     struct {
        BOOLEAN fcomp_bildung_gestoert           :1;
        BOOLEAN fcomp_schwelle_unterschritten    :1;
    } status_fcomp_berechnung;

    float       fcomp_gefiltert;// gefilterte Kompensierte Frequenz     //V.2.3.1
    float       p_gefiltert;    // gefiltert effektive Wirklieistung    //V.3.0.1
    struct      ALPHA_BETA_STRUCT alpha_beta;

}__attribute__((packed));
#pragma pack()  // pragma pack end 


//***************  Funktions-Prototypen  *******************************************
void SetMainTimerInit(u32_t IntrPriority);
BOOLEAN SetEthernetInit(void);


//***************  HW-PINs  ********************************************************

//Test Pin 200 = P1[29]
#define TESTPIN200_MASK			(1UL<<29) // -> Pin 29
#define TESTPIN200_INIT()		FIO1DIR |= TESTPIN200_MASK 	//Als Ausgang
#define TESTPIN200_HIGH()		FIO1SET  = TESTPIN200_MASK 	
#define TESTPIN200_LOW() 		FIO1CLR  = TESTPIN200_MASK	
#define TESTPIN200_TOGGLE()		FIO1PIN ^= TESTPIN200_MASK 	

//Test Pin 201 = P0[0]
#define TESTPIN201_MASK			(1UL) // -> Pin 0
#define TESTPIN201_INIT()		FIO0DIR |= TESTPIN201_MASK 	//Als Ausgang
#define TESTPIN201_HIGH()		FIO0SET  = TESTPIN201_MASK 	
#define TESTPIN201_LOW() 		FIO0CLR  = TESTPIN201_MASK	
#define TESTPIN201_TOGGLE()		FIO0PIN ^= TESTPIN201_MASK 	

#ifndef HW_REV_4_0               //vor HW Rev 4.0
    //Fehler-LED Port P0[4]
    #define FEHLER_LED_MASK			(1UL<<4) // -> Pin 4
    #define FEHLER_LED_INIT()		FIO0DIR |= FEHLER_LED_MASK 	//Als Ausgang
    #define FEHLER_LED_OFF()		FIO0SET  = FEHLER_LED_MASK 	
    #define FEHLER_LED_ON() 		FIO0CLR  = FEHLER_LED_MASK	
    #define FEHLER_LED_TOGGLE()		FIO0PIN ^= FEHLER_LED_MASK 	
#else               //Erst ab HW Rev 4.0
    //Fehler-LED Port P0[4]
    #define FEHLER_LED_MASK			(1UL<<4) // -> Pin 4
    #define FEHLER_LED_INIT()		FIO0DIR |= FEHLER_LED_MASK 	//Als Ausgang
    #define FEHLER_LED_ON() 		FIO0SET  = FEHLER_LED_MASK 	//LEDs sind invertiert
    #define FEHLER_LED_OFF() 		FIO0CLR  = FEHLER_LED_MASK
    #define FEHLER_LED_TOGGLE()		FIO0PIN ^= FEHLER_LED_MASK 	

    //System-LED Port P0[9]
    #define SYSTEM_LED_MASK			(1UL<<9) // -> Pin 9
    #define SYSTEM_LED_INIT()		FIO0DIR |= SYSTEM_LED_MASK 	//Als Ausgang
    #define SYSTEM_LED_ON()         FIO0SET  = SYSTEM_LED_MASK 	//LEDs sind invertiert
    #define SYSTEM_LED_OFF() 		FIO0CLR  = SYSTEM_LED_MASK	
    #define SYSTEM_LED_TOGGLE()		FIO0PIN ^= SYSTEM_LED_MASK 	
#endif  //#ifdef HW_REV_4_0

//TCS_SPI0 = P4[15]
#define CS_SPI0_PIN_MASK		(1UL<<15) // -> Pin 15
#define CS_SPI0_PIN_INIT()		FIO4DIR |= CS_SPI0_PIN_MASK 	//Als Ausgang
#define CS_SPI0_PIN_EN()		FIO4CLR  = CS_SPI0_PIN_MASK      //low active
#define CS_SPI0_PIN_DIS() 		FIO4SET  = CS_SPI0_PIN_MASK      //low active

//CS_SPI1 = P4[16]
#define CS_SPI1_PIN_MASK		(1UL<<16) // -> Pin 16
#define CS_SPI1_PIN_INIT()		FIO4DIR |= CS_SPI1_PIN_MASK 	//Als Ausgang
#define CS_SPI1_PIN_EN()		FIO4CLR  = CS_SPI1_PIN_MASK      //low active
#define CS_SPI1_PIN_DIS() 		FIO4SET  = CS_SPI1_PIN_MASK      //low active

//ACADC CONVST-Pin = P2[8]
#define CONVST_PIN_MASK			(1UL<<8) // -> Pin 8
#define CONVST_PIN_INIT()		FIO2DIR |= CONVST_PIN_MASK 	//Als Ausgang
#define CONVST_PIN_LOW()		FIO2CLR  = CONVST_PIN_MASK
#define CONVST_PIN_HIGH()		FIO2SET  = CONVST_PIN_MASK

//Gain-Pin zum umstellen der Verstärkung der AC-Ströme
#define GAIN_PIN_MASK           (1UL<<31) // -> Pin 31
#define GAIN_PIN_INIT()			FIO2DIR |= GAIN_PIN_MASK //Als Ausgang
#define GAIN_PIN_LOW()			FIO2CLR  = GAIN_PIN_MASK
#define GAIN_PIN_HIGH()			FIO2SET  = GAIN_PIN_MASK 

//PROFIBUS-Reset-Pin = P3[22]
#define PROFIBUS_RESET_PIN          (1UL<<22)
#define PROFIBUS_RESET_PIN_INIT()	FIO3DIR |= PROFIBUS_RESET_PIN  //Als Ausgang
#define PROFIBUS_RESET_PIN_LOW()	FIO3CLR  = PROFIBUS_RESET_PIN
#define PROFIBUS_RESET_PIN_HIGH()	FIO3SET  = PROFIBUS_RESET_PIN

//PROFIBUS-INTERRUPT-Pin = P2[10]
#ifdef HW_REV_1_1
	#define PROFIBUS_IRQ_PIN		(FIO2PIN & (1UL<<10))
#else
	#define PROFIBUS_IRQ_PIN		(FIO2PIN & (1UL<<11))
#endif

//PROFIBUS-Interrupt-Pin = EINT0
#define ENABLE_PROFIBUS_INT()	VICINTENABLE_bit.EINT0 = 1
#define DISABLE_PROFIBUS_INT()	VICINTENCLEAR_bit.EINT0 = 1

//Drehschalter P0[5-8]
#define DREHSCHALTER_MASK		0xF
#define DREHSCHALTER			((FIO0PIN >> 5) & DREHSCHALTER_MASK)

//HW-Kennung P0[29-31]
#define HW_KENNUNG_MASK			0x7
#define HW_KENNUNG				((FIO0PIN >>29) & DREHSCHALTER_MASK)

//Boot-Jumper P2[10]
#define BOOT_JUMPER				((FIO2PIN>>10) & 1UL)
#define BOOT_JUMPER_OPEN		1
#define BOOT_JUMPER_CLOSED		0

//PROFIBUS-Interrupt-Pin
#define PROFIBUS_INT			EINT0


//***************  Defines für Fehlererkennung  ************************************
#define ADC_FEHLER_LIMIT			200		//Anzahl Identischer Messwerte die nötig
											//sind um einen ADC Fehler darzustellen


//***************  Defines für Ethernet  ********************************************

#define ETHERNET_CHANNEL 			0

#define QUELL_IP_ADRESSE 			0xC0A80163 // 192.168.1.99
#define ZIEL_IP_ADRESSE 			0xC0A80164 // 192.168.1.100
#define BROADCAST_IP_ADRESSE        0xC0A801FF // 192.168.1.255

#define ETHERNET_FRAME_TYPE_IP_V4 	0x0800 // 0x0800 = IPv4
#define ETHERNET_FRAME_TYPE_ARP 	0x0806 // 0x0008 = ARP

#define FALLBACK_QUELL_MAC_ADRESSE  {0x01, 0x02, 0x03, 0x04, 0x05, 0x06}
#define FALLBACK_ZIEL_MAC_ADRESSE 	{0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF} //Broadcast

#define IP_HEADER_PROTOCOL_TYPE_UDP 17

#define QUELL_UDP_PORT 				0x8001
#define ZIEL_UDP_PORT  				0x8000
#define ZIEL_UDP_PORT_KALIBRIERUNG  0x9000

#define ARP_TIMEOUT					10     //10sec


//*****************Defines für den Ethernet-Chip

#define PHY_ADDRESS					1


//***************  Defines für die Konfiguration ***********************************

#define MESSBEREICH_100V			0
#define MESSBEREICH_110V			1
#define MESSBEREICH_120V			2

#define MESSBEREICH_1A				1
#define MESSBEREICH_5A				5

#define MESSBEREICH_0_20MA			0
#define MESSBEREICH_4_20MA			4

#define LIFEBIT_MASK                (0x80)


//***************  Defines für die DCADC *******************************************

#define COMMAND_CHANNEL1 0x0000
#define COMMAND_CHANNEL2 0x0800
#define COMMAND_CHANNEL3 0x1000


//***************  Defines für die EEPROM ******************************************

#define EEPROM_SLAVE_ADDRESS 	0x50 // Control Code + Chip Select Bits (siehe Datenblatt des 24AA02E48)
#define WRITE_BIT				0
#define READ_BIT				1
#define HIGHEST_READ_ADDRESS	0xFF
#define HIGHEST_WRITE_ADDRESS	0x7F //The range from 0x80 to 0xFF is write protected
#define PAGE_WRITE_BUFFER_SIZE  8    //8 Byte
#define	MAC_ARRAY_START_ADDRESS 0xFA //Adresse an der das erste Byte der MAC-Adresse im EEPROM gesperichert ist 
#define KALIBRIERUNGSWERTE_START_ADDRESS 0 //Adresse von der an beginnend die Kalbibrierungswerte gespeichert werden
//#define PARAMETER_MODUS2_START_ADDRESS   ((KALIBRIERUNGSWERTE_START_ADDRESS + sizeof(struct KALIBRIERUNG_STRUCT)) + 5)
// Ab Version 3.0.1 werden die Kalibrierungsdaten komprimiert im EEPROM gespechert
#define LOWEST_POSSIBLE_START_ADDRESS    (KALIBRIERUNGSWERTE_START_ADDRESS + SIZEOF_KALIBRIERUNGSWERTE_KOMPRIMIERT)
#define PARAMETER_MODUS2_START_ADDRESS   ( LOWEST_POSSIBLE_START_ADDRESS + (8 - (LOWEST_POSSIBLE_START_ADDRESS % 8)) ) //V.3.0.1
                                           //Adresse an die die Paramter für den Modus 2 gespeichert werden
                                           // Achtung: muss mod 8 = 0 sein!

//***************  Defines für die PROFIBUS ******************************************

#define PROFIBUS_IRQ			0
#define SET_PROFIBUS_RESET()	PROFIBUS_RESET_PIN_HIGH()
#define CLR_PROFIBUS_RESET()	PROFIBUS_RESET_PIN_LOW()
#define PRFIBUS_DEVICE_NAME		{ 0x4E, 0x54, 0x47, 0x2D, 0x33, 0x30, 0x30, 0x30, 0x20, 0x20, 0x20, 0x20 } //"NTG-3000    "
#define DP_ADDR                 ((u8_t)0x01)     //PROFIBUS Slave address
#define IDENT_NR                ((UWORD)0x3000)   // PROFIBUS Ident Number


//*************************** Defines für die Kalibrierung *********************

//#define N_MESSUNGEN_DC			10 //Anzahl Messungen über die die Mittelwerte gebildet werden.
//NEU
#define N_MESSUNGEN_DC			8 //Anzahl Messungen über die die Mittelwerte gebildet werden.
#define N_MESSUNGEN_AC		  200 //Anzahl Messungen über die die Mittelwerte gebildet werden.
#define TOLERANZ_MAX_IN_PROZ	 5 //Toleranz für den Plausibilitätstest der pos. u. neg. Werte in %
#define TOLERANZ_NULL_IN_PROZ	 2 //Toleranz für den Plausibilitätstest der Werte um den Nullpunkt in %

//
//Erwartete Wert (abgeleitet aus der auslegung der HW)
//
#define ERWARTETER_WERT_POS_U_AC		1625
//Kalibrierungs-SW-V.2.2
// Anpassung an die geänderte Bestückung der HW Rev 5.1
//#define ERWARTETER_WERT_POS_I_AC_5A	1470
#define ERWARTETER_WERT_POS_I_AC_5A		1323 //Kalibrierungs-SW-V.2.2
//#define ERWARTETER_WERT_POS_I_AC_1A	1540
#define ERWARTETER_WERT_POS_I_AC_1A		1333 //Kalibrierungs-SW-V.2.2

#define ERWARTETER_WERT_POS_I_DC		3703
#define ERWARTETER_WERT_POS_U_DC		3664

#define ERWARTETER_WERT_NEG_U_AC		(-1625)
#define ERWARTETER_WERT_NEG_I_AC_5A		(-ERWARTETER_WERT_POS_I_AC_5A)	
#define ERWARTETER_WERT_NEG_I_AC_1A		(-ERWARTETER_WERT_POS_I_AC_1A)

#define ERWARTETER_WERT_NULL_I_AC_5A	0
#define ERWARTETER_WERT_NULL_I_AC_1A	0
#define ERWARTETER_WERT_NULL_U_AC		0
#define ERWARTETER_WERT_NULL_I_AC		0
#define ERWARTETER_WERT_NULL_I_DC		0
#define ERWARTETER_WERT_NULL_U_DC		0


//************************** Defines für Normierung ****************************

#define IDEALER_SOLLWERT_POS_U_AC		1671		//bei 100V 	(122,47V = 2047 --> 100V = 1671,43
#define IDEALER_SOLLWERT_POS_I_AC_5     1447		//bei   7A	( 9,899A = 2047 -->   7A = 1447,52 
#define IDEALER_SOLLWERT_POS_I_AC_1A    1447		//bei 1,4A  (  1,98A = 2047 --> 1,4A = 1447,37

#define IDEALER_SOLLWERT_POS_I_DC		3723		//bei 20mA  (   22mA = 4095 --> 20mA = 3722,73
#define IDEALER_SOLLWERT_POS_U_DC		3723		//bei  10V	(    11V = 4095 -->  10V = 3722,73

#define IDEALER_SOLLWERT_NEG_U_AC		(-1671)		//bei -100V
#define IDEALER_SOLLWERT_NEG_I_AC_5A	(-1447)		//bei -7A
#define IDEALER_SOLLWERT_NEG_I_AC_1A	(-1447)		//bei -1,4A

//********************* Defines für die Dynamische Offset-Erkennung *************
#define STARTSCHWELLE	102 //= 11 Bit = 2048 * 5%

//********************* Defines für den Modus 2 ("Brechungsmodus") *************
// Werte für die Parameter die verwendet werden wenn keine Werte aus dem EEPROM
// ausgelesen werden konnten
#define DEFAULT_PARAMETER_FAKTRO_I                1.0
#define DEFAULT_PARAMETER_FAKTOR_U                1.0
#define DEFAULT_PARAMETER_FAKTOR_ABTASTZEIT       0
#define DEFAULT_PARAMETER_XQ                      2.0
#define DEFAULT_PARAMETER_TA                      1.0/5000
#define DEFAULT_PARAMETER_F0                     50.0
#define DEFAULT_PARAMETER_SCHWELLE_SKALARPRODUKT  0.01

//v.3.3 entfallen:
/*
//V.2.3.1
#define DEFAULT_PARAMETER_B0 2.413590490419615e-04f
#define DEFAULT_PARAMETER_B1 4.827180980839230e-04f
#define DEFAULT_PARAMETER_B2 2.413590490419615e-04f
#define DEFAULT_PARAMETER_A0 -1.955578240315037f
#define DEFAULT_PARAMETER_A1 0.956543676511205f
*/

//V.3.1.1
#define SIGNAL_INDEX_FCOM_GEFILTERT     0
#define SIGNAL_INDEX_P_GEFILTERT        1

//********************* Defines für das Mathematik-Modul ************************
#define AD_NULL_PUNKT 0

//******************* Defines für die Frequenz-Ermittlung ***********************
#define U_MIN_FREQUENZ_ERMITTLUNG 0.3 //Effektivspannung unter der keine Frequnez
                                      //Messung durchgeführt wird (1 = U_eff_nenn)

//*************** Defines für Spannungsphasen-Ausfalls-Überwachung **************
#define GENZWERT_SPANNUNGSSUMME_PHASENAUSFALL   (0.19)
#define HYSTERESE_PHASENAUSFALL                 (0.01)

//****************** DEBUG DEFINES **********************************************

#define MIT_PROFIBUS
#define POLL_PROFIBUS_IRQ

//#define DEBUG_SW_SPI

#undef OHNE_NORMIERUNG
//#warning Normierung vorrübergehend daktiviert!
