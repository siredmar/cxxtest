/*******************************************************************************************************************************************
*
* Projekt:    TB20 - MAGPIE (WEIGHING MODULE)
* Datei:      app.c
* 
* Autor:      Marc Bergmann (MB)
* Copyright:  2015 Systeme Helmholz GmbH
* 
* Zweck:      Realisierung der Modulapplikation
*
*******************************************************************************************************************************************/

#include "app.h"
#include "cis.h"
#include "ais.h"
#include "app_imh.h"
#include "app_cif.h"
#include "swt.h"
#include "Wzm.h"
#include "Adc.h"
#include <string.h>

#ifndef  FW_MAGPIE_DIOTEST

  //#error  Die aktuelle Implementierung der Modul-Applikation dient nur als Projektrahmen in Verbindung mit dem Macro FW_MAGPIE_DIOTEST

#endif
	
	
/*****   Lokale Typedefs und Defines  *****************************************************************************************************/

// Defines f¸r die Typen in APP_Param_DataStructure_Data und APP_CyclicIO_CurrentIOConfig_DataStructure
#define BYTE        1   // (enth‰lt Bits)
#define UNSIGNED8   2
#define SIGNED8     3
#define UNSIGNED16  4
#define SIGNED16    5
#define UNSIGNED32  6
#define SIGNED32    7	


/*****   Globale Funktionen   *************************************************************************************************************/

  void                        APP_Module_Init           ( u16_t  ModuleType );
  void                        APP_Module_Process        ( void );

  void                        AIS_FatalError_Callback   ( tCIS_IFM_SourceModule   SourceModule,
                                                          u32_t                   SourceLine,
                                                          u32_t                   Info );


/*****   Globale Variablen   **************************************************************************************************************/

  u8_t                        AIS_CyclicIO_CurrentIOConfig_InputDataSize;
  u8_t                        AIS_CyclicIO_CurrentIOConfig_OutputDataSize;

  u8_t*                       AIS_CyclicIO_CurrentIOConfig_DataStructure_Pointer;
  u8_t                        AIS_CyclicIO_CurrentIOConfig_DataStructure_Length;

  u8_t                        APP_LastFatalError_Data[ 8 ]    __SECTION( ".lfedata" );

u8_t*     AIS_Parameters_DataStructure_Pointer;
u8_t      AIS_Parameters_DataStructure_Length;

u8_t*     AIS_CurrentParameters_DataPointer;
u8_t      AIS_CurrentParameters_DataLength;

bool_t    AIS_Diagnostics_DiagnosticAlarm_Activated;



/*****   APP_MainControl   *****************************************************************************************************************/

  static void                 APP_MainControl_Init                    ( u16_t  ModuleType );
  static void                 APP_MainControl_Process                 ( void );
  
  static void                 APP_MainControl_AppStateChanged_Init    ( void );
  static void                 APP_MainControl_AppStateChanged_Idle    ( void );
  static void                 APP_MainControl_AppStateChanged_Stop    ( void );
  static void                 APP_MainControl_AppStateChanged_Run     ( void );

  static tCIS_AS_AppState     APP_MainControl_CurrentAppState;
  static bool_t               APP_MainControl_Operational;



/*****   APP_CyclicIO   *******************************************************************************************************************/

  static void                 APP_CyclicIO_Init                                 ( void );
  static void                 APP_CyclicIO_Process                              ( void );
  static void                 APP_CyclicIO_SetIOConfig                          ( void );
  static void                 APP_CyclicIO_OutputData_Reset                     ( void );
  static void                 APP_CyclicIO_InputData_Reset                     ( void );
  
  static u8_t                 APP_CyclicIO_CurrentIOConfig_DataStructure_Data   [ 6 ];

  static u8_t                 APP_CyclicIO_OutputData [ CIS_SETTINGS_MAXSIZE_CIO_OUTPUT_DATA ];
  static u8_t                 APP_CyclicIO_InputData  [ CIS_SETTINGS_MAXSIZE_CIO_INPUT_DATA ];

static const u8_t	APP_CyclicIO_DataStructure_Data[] =
{
    CIS_SETTINGS_MAXSIZE_CIO_INPUT_DATA,	// Output Data Size (Output Data = TB20-Couppler to Module)
	4,										// Number of Input Data Elements
	SIGNED32,								// Element 0
	BYTE,									// Element 1
	BYTE,									// Element 2
	UNSIGNED16,								// Element 3
	CIS_SETTINGS_MAXSIZE_CIO_OUTPUT_DATA,	// Output Data Size (Input Data = from Module to TB20-Couppler)
	4, // Number of Output Data Elements
	SIGNED32,								// Element 0
	BYTE,									// Element 1
	BYTE,									// Element 2
	//UNSIGNED16							// Element 3
	//ToDo ggf. korrigieren
	BYTE									// Element 3
};

//////   APP_Diagnostics   /////////////////////////////////////////////////////////////////////////////////////////////////////////////////
#ifdef WZM_ENABLE_DIAGNOSTICS
static void     APP_Diagnostics_Init      ( void );
static void     APP_Diagnostics_Process   ( void );
#endif

u8_t     APP_Diagnostics_CurrentStatus       [ CIS_SETTINGS_MAXSIZE_DIAGNOSTIC_DATA ];
static u8_t     APP_Diagnostics_LastDeliveredStatus [ CIS_SETTINGS_MAXSIZE_DIAGNOSTIC_DATA ];


/*****   APP_Param   *******************************************************************************************************************/

static void		APP_Param_Init      ( void );
static void     APP_Param_Process   ( void );

static void     APP_Param_CurrentParams_CopyDefault	( void );
static u8_t     APP_CheckParameterInvalid		( void );

 u8_t   APP_Param_CurrentParams_Data[ CIS_SETTINGS_MAXSIZE_PARAM_DATA ];
 u8_t   APP_Param_CurrentParams_Length;
 bool_t APP_Param_CurrentParams_Valid;

static const u8_t   APP_Param_DataStructure_Data[] = 		
{
	// Achtung: Die durch dieses Array beschriebene Struktur muss MODUL_PARAMETER ¸bereinstimmen

	1,   // Anzahl an Parameter-Sets = 4
	//
	// Parameter-Set 0:
	//
	CIS_SETTINGS_MAXSIZE_PARAM_DATA,			// L‰nge der Parameterdaten in Bytes
	//
	10 + 0x80,  // Anzahl der Elemente, Bit 7 = 1 --> App ID im n‰chsten Byte
	//
	1,			// Application ID = Betriebsart (0. Element)
	BYTE,       // Datentyp des 1. Elements, Byte 0
	BYTE,       //    "         2.    "    , Byte 1
	UNSIGNED8,	//    "         3.    "    , Byte 2
	UNSIGNED8,  //    "         4.    "    , Byte 3
	UNSIGNED16,	//    "         5.    "    , Byte 4 bis- 5
	UNSIGNED32, //    "         6.    "    , Byte 6 bis 9
	UNSIGNED16, //    "         7.    "    , Byte 10 bis 11
	UNSIGNED16, //    "         8.    "    , Byte 12 bis 13
	BYTE 		//    "         9.    "    , Byte 14

	// Mˆgliche Werte: BYTE, SIGNED8, UNSIGNED8, UNSIGNED16, UNSIGNED32, SIGNED32
};



/******************************************************************************************************************************************/
//////    FUNKTIONSDEFINITIONEN    /////////////////////////////////////////////////////////////////////////////////////////////////////////
/******************************************************************************************************************************************/

/***  APP_Module_Init  ***/

  void   APP_Module_Init( u16_t  ModuleType )
  {    
    // Application Steuerung initialisieren
    APP_MainControl_Init( ModuleType );

    // Cyclic IO initialisieren
    APP_CyclicIO_Init();
	
	// Initialisierung der IO-Daten-Behandlung
    APP_Param_Init();
    
    // IM-Kommando-Handling initialisieren
    APP_IMH_Module_Init();

    // ueber Rueckwandbus getunneltes Kommando-Interface initialisieren
    APP_CIF_Module_Init();

#ifdef WZM_ENABLE_DIAGNOSTICS
    // Initialisierung der Diagnose-Behandlung
    APP_Diagnostics_Init();
#endif

    Wzm_Init();
    
    // Modul ist betriebsbereit
    APP_MainControl_Operational = 1;
    
    return;
  }




/***  APP_Module_Process  ***/

  void   APP_Module_Process( void )
  {
	static u16_t test = 0;
	u16_t test_mittelwert = 0;
	  
    APP_MainControl_Process();
	  
	// zyklische Bearbeitungsroutine der Parameter-Behandlung aufrufen
	APP_Param_Process();

    APP_CyclicIO_Process();
#ifdef WZM_ENABLE_DIAGNOSTICS
	APP_Diagnostics_Process();
#endif
    if ( APP_IMH_IMCommandHandling_InProgress )
    {  
      APP_IMH_Module_Process();
    }
    
    APP_CIF_Module_Process();

    Wzm_Handler();

    return;
  }



/***  AIS_FatalError_Callback  ***/

  void  AIS_FatalError_Callback( tCIS_IFM_SourceModule   SourceModule,
                                     u32_t                   SourceLine,
                                     u32_t                   Info )
  {
             u8_t  CheckSum;    
    volatile u8_t  Test;
    
    // alle Interrupts sperren
    
    __disable_irq();
    
    // Informationen zum fatalen Fehler in speziellem Array merken
    // -> diese Informationen sollten auch nach Watchdog-Reset noch zur Verfuegung stehen
    //    und koennen ueber das entsprechende IM-Kommando abgerufen werden
    
    CheckSum  = APP_LastFatalError_Data[ 0 ] = SourceModule;
    CheckSum += APP_LastFatalError_Data[ 1 ] = SourceLine >> 8;
    CheckSum += APP_LastFatalError_Data[ 2 ] = SourceLine >> 0;
    CheckSum += APP_LastFatalError_Data[ 3 ] = Info >> 24;
    CheckSum += APP_LastFatalError_Data[ 4 ] = Info >> 16;
    CheckSum += APP_LastFatalError_Data[ 5 ] = Info >> 8;
    CheckSum += APP_LastFatalError_Data[ 6 ] = Info >> 0;
                APP_LastFatalError_Data[ 7 ] = CheckSum;

    Test = 1;
    
    while ( Test ) ;  // in der Release-Version schlaegt hier der Watchdog zu
  }



/***  APP_MainControl_Init  ***/

  static void  APP_MainControl_Init( u16_t  ModuleType )
  {
    switch ( ModuleType )
    {
      case  0x0188:   // Modul-Typ vom 8DI/8DO-Modul fuer FW_MAGPIE_DIOTEST
      case	0x2201:
      {
        // alles OK
    
        break;       
      }

      default:
      {
        /* falscher Modultyp */
        
        // -> ab in die Endlosschleife
        
        while ( 1 )
        {
          // Watchdog fuettern
        
          LPC_WDT->FEED = 0xAA;
          LPC_WDT->FEED = 0x55;
          
          handle_leds();
        }        
      }
    }
    
    APP_MainControl_CurrentAppState = eCIS_AS_AppState_Init;
    
    return;
  }



/***  APP_MainControl_Process  ***/

  static void  APP_MainControl_Process( void )
  {
    tCIS_AS_AppState  CurrentAppState;
    
    CurrentAppState = CIS_AS_CurrentAppState;
    
    if ( APP_MainControl_CurrentAppState != CurrentAppState )
    {
      switch ( CurrentAppState )
      {
        case  eCIS_AS_AppState_Init:          APP_MainControl_AppStateChanged_Init();    break;
        case  eCIS_AS_AppState_Idle:          APP_MainControl_AppStateChanged_Idle();    break;
        case  eCIS_AS_AppState_Active_Stop:   APP_MainControl_AppStateChanged_Stop();    break;
        case  eCIS_AS_AppState_Active_Run:    APP_MainControl_AppStateChanged_Run();     break;
        
        default:                              while ( 1 ) ;;;
      }
    }
    
    return;
  }


/***  APP_MainControl_AppStateChanged_Init  ***/

  static void  APP_MainControl_AppStateChanged_Init( void )
  {
    CIS_AS_Initialization_Started();
	  
	APP_Param_CurrentParams_CopyDefault();
    APP_Param_CurrentParams_Activate();
    
    APP_MainControl_CurrentAppState = eCIS_AS_AppState_Init;
   
    //APP_CyclicIO_OutputData[ 0 ] = 0;
    //APP_CyclicIO_InputData [ 0 ] = 0;
	APP_CyclicIO_OutputData_Reset();
	APP_CyclicIO_InputData_Reset();
#ifdef WZM_ENABLE_DIAGNOSTICS
	APP_Diagnostics_Init();
#endif
    CIS_AS_CyclicIO_DeliverNewInputData( APP_CyclicIO_InputData );
    
    CIS_AS_Initialization_Finished();

    return;
  }


/***  APP_MainControl_AppStateChanged_Idle  ***/

  static void  APP_MainControl_AppStateChanged_Idle( void )
  {
    //APP_CyclicIO_OutputData[ 0 ] = 0;
    //APP_CyclicIO_InputData [ 0 ] = 0;
	APP_CyclicIO_OutputData_Reset();
	APP_CyclicIO_InputData_Reset();
    
    LEDAW_SetLED( 0, LED_BLINK_FAST );
    
    APP_MainControl_CurrentAppState = eCIS_AS_AppState_Idle;

    return;
  }


/***  APP_MainControl_AppStateChanged_Stop  ***/

  static void  APP_MainControl_AppStateChanged_Stop( void )
  {
    //APP_CyclicIO_OutputData[ 0 ] = 0;
    //APP_CyclicIO_InputData [ 0 ] = 0;
	APP_CyclicIO_OutputData_Reset();
	APP_CyclicIO_InputData_Reset();
    
    LEDAW_SetLED( 0, LED_BLINK );
    
    APP_MainControl_CurrentAppState = eCIS_AS_AppState_Active_Stop;

    return;
  }


/***  APP_MainControl_AppStateChanged_Run  ***/

  static void  APP_MainControl_AppStateChanged_Run( void )
  {
    LEDAW_SetLED( 0, LED_ON );
    
    APP_MainControl_CurrentAppState = eCIS_AS_AppState_Active_Run;
    
    return;
  }



/***  APP_CyclicIO_Init  ***/

  static void  APP_CyclicIO_Init( void )
  {
    APP_CyclicIO_SetIOConfig();
    
    //APP_CyclicIO_OutputData[ 0 ] = 0;
    //APP_CyclicIO_InputData [ 0 ] = 0;
	APP_CyclicIO_OutputData_Reset();
	APP_CyclicIO_InputData_Reset();
    
    return;
  }


/***  APP_CyclicIO_Process  ***/

  static void  APP_CyclicIO_Process( void )
  {
    if ( CIS_AS_InterfaceStatus.Flags.CyclicIO_NewOutputDataReceived )
    {
      //u8_t  ReceivedOutputData[ 1 ];
      u8_t  ReceivedInputData[ sizeof(APP_CyclicIO_InputData) ];
      
      CIS_AS_CyclicIO_FetchNewOutputData( (u8_t*) &ReceivedInputData );
      
      if ( ( APP_MainControl_CurrentAppState == eCIS_AS_AppState_Active_Run ) && APP_MainControl_Operational )
      {
		// Modul-Input-Kopller-Output-Daten aus den empfangenen Daten in die System-Struktur schreiben
        memcpy(&Wzm_Data_s.ModuleInputData_s, ReceivedInputData, sizeof(Wzm_Data_s.ModuleInputData_s));
        /* Swap bytes of Input value */
        Wzm_Data_s.ModuleInputData_s.Value = SWAP_4_BYTES(Wzm_Data_s.ModuleInputData_s.Value);
        memcpy(APP_CyclicIO_OutputData, &Wzm_Data_s.ModuleOutputData_s, sizeof(Wzm_Data_s.ModuleOutputData_s));
      }

      /* Parameter invalid -> Output it */
      if ( APP_MainControl_Operational == 0 )
      {
          memcpy(APP_CyclicIO_OutputData, &Wzm_Data_s.ModuleOutputData_s, sizeof(Wzm_Data_s.ModuleOutputData_s));
      }
    }
       
    if ( APP_MainControl_CurrentAppState >= eCIS_AS_AppState_Active_Stop )
    {
      CIS_AS_CyclicIO_DeliverNewInputData( APP_CyclicIO_OutputData );
    }
    return;
  }


/***  APP_CyclicIO_SetIOConfig  ***/

  static void  APP_CyclicIO_SetIOConfig( void )
  {
/*	  
    AIS_CyclicIO_CurrentIOConfig_InputDataSize  = 1;
    AIS_CyclicIO_CurrentIOConfig_OutputDataSize = 1;
    
    APP_CyclicIO_CurrentIOConfig_DataStructure_Data[ 0 ] = 0x01;  // Input Data Size
    APP_CyclicIO_CurrentIOConfig_DataStructure_Data[ 1 ] = 0x01;  // Number of Input Data Elements
    APP_CyclicIO_CurrentIOConfig_DataStructure_Data[ 2 ] = 0x01;  // Element 0 = Byte
    
    APP_CyclicIO_CurrentIOConfig_DataStructure_Data[ 3 ] = 0x01;  // Output Data Size
    APP_CyclicIO_CurrentIOConfig_DataStructure_Data[ 4 ] = 0x01;  // Number of Output Data Elements
    APP_CyclicIO_CurrentIOConfig_DataStructure_Data[ 5 ] = 0x01;  // Element 0 = Byte
    
    AIS_CyclicIO_CurrentIOConfig_DataStructure_Pointer = (u8_t*) APP_CyclicIO_CurrentIOConfig_DataStructure_Data;
    AIS_CyclicIO_CurrentIOConfig_DataStructure_Length  = 6;
*/
	AIS_CyclicIO_CurrentIOConfig_InputDataSize  = sizeof(APP_CyclicIO_InputData);
    AIS_CyclicIO_CurrentIOConfig_OutputDataSize = sizeof(APP_CyclicIO_OutputData);

    AIS_CyclicIO_CurrentIOConfig_DataStructure_Pointer = (u8_t*) APP_CyclicIO_DataStructure_Data;
    AIS_CyclicIO_CurrentIOConfig_DataStructure_Length  = sizeof( APP_CyclicIO_DataStructure_Data );

    return;
  }

/***  APP_CyclicIO_OutputData_Reset  ***/

static void  APP_CyclicIO_OutputData_Reset( void )
{
    memset(APP_CyclicIO_OutputData, 0, sizeof(APP_CyclicIO_OutputData));
    
    return;
}


/***  APP_CyclicIO_OutputData_Reset  ***/

static void  APP_CyclicIO_InputData_Reset( void )
{
    memset(APP_CyclicIO_InputData, 0, sizeof(APP_CyclicIO_InputData));
    
    return;
}


/***  APP_Param_Init  ***/

static void  APP_Param_Init( void )
{
    APP_Param_CurrentParams_CopyDefault();
    APP_Param_CurrentParams_Activate();
    
    AIS_Parameters_DataStructure_Pointer  = (u8_t*) APP_Param_DataStructure_Data;
    AIS_Parameters_DataStructure_Length   = sizeof( APP_Param_DataStructure_Data );
    
    return;
}


/***  APP_Param_Process  ***/

static void  APP_Param_Process( void )
{
    if ( CIS_AS_InterfaceStatus.Flags.Parameters_NewParametersReceived )
    {
        CIS_AS_Parameterization_FetchReceivedParameters( APP_Param_CurrentParams_Data,
                                                        &APP_Param_CurrentParams_Length );
        
        // Der Koppler √ºermittelt bei .cop.run immer eine 0 f√ºr die L√§nge
        if ( APP_Param_CurrentParams_Length == 0 )
        {
            APP_Param_CurrentParams_CopyDefault();
        }

        APP_Param_CurrentParams_Activate();
        
//		CIS_AS_CyclicIO_DeliverNewInputData( APP_CyclicIO_InputData );

        CIS_AS_Parameterization_Finished();
    }    
    
    return;
}


/***  APP_Param_CurrentParams_CopyDefaultParameters  ***/

static void  APP_Param_CurrentParams_CopyDefault( void )
{
#ifdef WZM_ENABLE_DIAGNOSTICS
    APP_Param_CurrentParams_Data[0]  = 0x21u; /* Operation Mode = Normal, Diagnostic = Enabled */
#else
    APP_Param_CurrentParams_Data[0]  = 0x01u; /* Operation Mode = Normal */
#endif
    APP_Param_CurrentParams_Data[1]  = 0x10u; /* Measurement Range = 4mV/V, Output Unit = mV/V */
    APP_Param_CurrentParams_Data[2]  = 0x01u; /* Average values = 1 */
    APP_Param_CurrentParams_Data[3]  = 0x00u; /* Used nodes = 0 */
    APP_Param_CurrentParams_Data[4]  = 0x00u; /* Rated ouutput = 1 */
    APP_Param_CurrentParams_Data[5]  = 0x01u; /* Rated ouutput = 1 */
    APP_Param_CurrentParams_Data[6]  = 0x00u; /* Nominal Load = 1 */
    APP_Param_CurrentParams_Data[7]  = 0x00u; /* Nominal Load = 1 */
    APP_Param_CurrentParams_Data[8]  = 0x00u; /* Nominal Load = 1 */
    APP_Param_CurrentParams_Data[9]  = 0x01u; /* Nominal Load = 1 */
    APP_Param_CurrentParams_Data[10] = 0x00u; /* Min bridge voltage = 0 */
    APP_Param_CurrentParams_Data[11] = 0x00u; /* Min bridge voltage = 0 */
    APP_Param_CurrentParams_Data[12] = 0x00u; /* Max bridge voltage = 0 */
    APP_Param_CurrentParams_Data[13] = 0x00u; /* Max bridge voltage = 0 */
    APP_Param_CurrentParams_Data[14] = 0x00u; /* Reserved */
    APP_Param_CurrentParams_Length = 15u;
    APP_Param_CurrentParams_Activate();
	return;
}

/***  APP_Param_CurrentParams_Activate  ***/

void  APP_Param_CurrentParams_Activate( void )
{
	u8_t	OperationMode;
	bool_t	new_params_received = FALSE;
	
	// Die Betreibsart steht immer im 0. Byte
	OperationMode = APP_Param_CurrentParams_Data[0];

	if ( OperationMode == 1 && APP_Param_CurrentParams_Length == sizeof(Wzm_ParameterType))
	{
        /* Reset outputs */
        Wzm_Data_s.ModuleOutputData_s.BridgeVoltageSupplyExceeded = 0;
        Wzm_Data_s.ModuleOutputData_s.BridgeVoltageSupplyTooLow = 0;
        Wzm_Data_s.ModuleOutputData_s.CommandFinished = 0;
        Wzm_Data_s.ModuleOutputData_s.ErrorReadWriteNode = 0;
        Wzm_Data_s.ModuleOutputData_s.OpenCircuit = 0;
        Wzm_Data_s.ModuleOutputData_s.InvalidParameter = 0;
        Wzm_Data_s.ModuleOutputData_s.Value = 0;
        Wzm_Data_s.ModuleOutputData_s.AdcOverflow = 0;
        Wzm_Data_s.ModuleOutputData_s.ValueValid = FALSE;

		memcpy(&Wzm_Data_s.ParameterData_s, APP_Param_CurrentParams_Data, sizeof(Wzm_ParameterType));
		
		// Ggf. Byte Order anpassen
		Wzm_Data_s.ParameterData_s.Wzm_LoadCellVoltage = SWAP_2_BYTES(Wzm_Data_s.ParameterData_s.Wzm_LoadCellVoltage);
		Wzm_Data_s.ParameterData_s.Wzm_NominalLoad = SWAP_4_BYTES(Wzm_Data_s.ParameterData_s.Wzm_NominalLoad);
		Wzm_Data_s.ParameterData_s.Wzm_MinBridgeSupply = SWAP_2_BYTES(Wzm_Data_s.ParameterData_s.Wzm_MinBridgeSupply);
		Wzm_Data_s.ParameterData_s.Wzm_MaxBridgeSupply = SWAP_2_BYTES(Wzm_Data_s.ParameterData_s.Wzm_MaxBridgeSupply);

		/* (Re-)Init Average Buffer */
		Wzm_InitAverageBuffer();
		Wzm_Data_s.CommandExecutionPending_ui8 = FALSE;

        /* Change word rate if changed */
        if((Adc_GetWordRate() != (Adc_WordRatesType)Wzm_Data_s.ParameterData_s.Wzm_WordRate_e) || \
           (Adc_GetMeasurementRange() != (Adc_MeasurementRangeType)Wzm_Data_s.ParameterData_s.Wzm_MeasurementRange_e))
        {
            Adc_ChangeParameters(Wzm_Data_s.ParameterData_s.Wzm_WordRate_e, Wzm_Data_s.ParameterData_s.Wzm_MeasurementRange_e);
        }

        Wzm_ChangeNumberOfUsedNodes(Wzm_Data_s.ParameterData_s.Wzm_NumberOfNodes);

		/* Default measurement mode: Ch1, Continuous */
		Adc_SetCurrentState(ADC_STATE_CONTINUOUS_MODE, ADC_CHANNEL1);

		new_params_received = TRUE;
	}
	else
	{
		new_params_received = FALSE;
		APP_Param_CurrentParams_Valid  = 0;
    }
	
	// Wenn neue Paramater empfangen wurden, diese Pr√ºfen
	if (new_params_received)
	{
        // Pr√ºfen ob die eingelesenen Daten ok sind
        if(Wzm_CheckParameterInvalid() == FALSE)
        {
            APP_Param_CurrentParams_Valid  = 1;
        }
        else
        {
            APP_Param_CurrentParams_Valid = 0;
        }
	}
		
    // Wenn die Empfangene Parametrierung g√ºltig ist
    if ( APP_Param_CurrentParams_Valid )
    {
        APP_MainControl_Operational = 1;

        // Korrekte Parametrierung √ºber LEDs anzeigen
        LEDAW_SetLED( 1, LED_OFF );
    }
    else
    {
		APP_Param_CurrentParams_Length = 1;
		
        APP_MainControl_Operational = 0;
        
        APP_CyclicIO_OutputData_Reset();
        /* TODO aschl : Check if this is needed */
        Wzm_Data_s.ModuleOutputData_s.InvalidParameter = 1u;
        
        // Fehlerhafte Parametrierung √ºber LEDs anzeigen
        LEDAW_SetLED( 1, LED_BLINK );
		
		// Diagnosealarme auf TRUE setzen damit der Alarm "Falsche Parametrierung" auf jeden Fall gemeldet wird
		AIS_Diagnostics_DiagnosticAlarm_Activated = TRUE;
    }
    

    AIS_CurrentParameters_DataPointer = APP_Param_CurrentParams_Data;
    AIS_CurrentParameters_DataLength  = APP_Param_CurrentParams_Length;
    
    return;
}
#ifdef WZM_ENABLE_DIAGNOSTICS
void APP_DiagnosticAlarmState(u8_t State)
{
    AIS_Diagnostics_DiagnosticAlarm_Activated = State;
}
#endif

//#ifdef WZM_ENABLE_DIAGNOSTICS
/***  APP_Diagnostics_Init  ***/
static void  APP_Diagnostics_Init( void )
{
    APP_Diagnostics_LastDeliveredStatus[ 0 ] = 0x00;

    return;
}

/***  APP_Diagnostics_Process  ***/
static void  APP_Diagnostics_Process( void )
{
//    if ( APP_Param_CurrentParams_Valid )
//    {
//        APP_Diagnostics_CurrentStatus[ 0 ] = 0x00;
//    }
//    else
//    {
//        APP_Diagnostics_CurrentStatus[ 0 ] = 0x12;
//    }
    if (((     APP_Diagnostics_CurrentStatus[ 0 ] != APP_Diagnostics_LastDeliveredStatus[ 0 ] ))
    && ( !CIS_AS_InterfaceStatus.Flags.Diagnostics_StatusDeliveryPending ))
    {
        CIS_AS_Diagnostics_DeliverChangedStatus( APP_Diagnostics_CurrentStatus, 1 );

        APP_Diagnostics_LastDeliveredStatus[ 0 ] = APP_Diagnostics_CurrentStatus[ 0 ];
    }

    return;
}
//#endif
