//***************************************************************************
//
// Module      : Utilities.c                ==>     DCon2010 - M E A S U R E
//
// Author      : Reiner Beh
// Date        : 04.07.11
// Last update : 07.12.12
// This update : 12.12.12
//
// Description : Initialisierungen
//
// Remarks     :
//
// Functions   :                                                               > Zeitdauer
//
// - LED_ToggleTest()                                               07.12.12
// - LED_Switch()                                                   23.10.12
// - LED_Signal()                                                   23.10.12
// - LED_Toggle()                                                   07.12.12
// - LED_ToggleAndStop()                                            07.12.12
// - LED_ToggleAndWait()                                            07.12.12
//
// - CalcChecksum()                                                 09.08.11
//
// - CheckFalseCnt()                                                12.12.12
// - SetDataZero()                                                  12.12.12
// - SelectSamples()                                                12.12.12
// - SelectSamples_CLV()                                            12.12.12
// - Convert_PHX()                                                  02.09.12
//
// - Convert_ADCdata_PHU_StartSample()                              23.07.12   > ~   3 µs
// - Convert_ADCdata_PHU_Samples_FP()                               13.06.12   > ~     µs
// - Convert_ADCsamples_HP()                                        11.07.12   > ~  35 µs
// - Convert_PH_PHU()                                               16.08.12   > ~ 150 µs
// - Convert_PH_PHV()                                               11.07.12
// - Convert_PH_PHW()                                               11.07.12
//
// - ConvertToDecimal()                                             05.02.10
//
// - CheckSwReset()                                                 25.09.12
//
//***************************************************************************

//---------------------------------------------------------------------------
// Include
//---------------------------------------------------------------------------

#include <Math.h>
#include <stdio.h>
#include <errno.h>

#include "Definitions.h"
#include "Externals.h"

#include "Utilities.h"


//>==========================================================================
// G O B A L S
//>==========================================================================
struct st_Samples stSamples[4];
struct st_ADC stADC;
struct st_ActValue stActValue;

unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;

/* HSP FIX - 03.08.2016: Put variable in flash with default values that can be overwritten in hex file afterwards
                         with the compensated offset value. Default is ADC_MAXVALUE_HALF = 2048
                         All occurrences of the macro ADC_MAXVALUE_HALF have been replaced with Adc_Maxhalf_Value[0] */
const unsigned short __attribute__((space(prog), address(0x200), section("Adc_Offset"))) Adc_Maxhalf_Value[1] = {1445}; // 0x5a5
unsigned short * Adc_MaxHalf_Ptr;
//===========================================================================
//
// Function    : LED_ToggleTest
//
// Date        : 07.12.12
// Last update : 07.12.12
// This update : 07.12.12
//
// Description : 
//
// Input       : -
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_ToggleTest(void)
{
unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;
unsigned long ulWaitTimeOuter, ulWaitTimeInner;
unsigned int uiLEDstate;

#ifdef TEST_LED_TXD_MESS_ACTIVE
  // ================================================================
  // Ausgang TXD_MESS für TEST-LED initialisieren
  // ================================================================
  TRISBbits.TRISB12 = 0;        // Output RB12: TEST-LED an TXD_MESS => Pin 20
#endif  // TEST_LED_TXD_MESS_ACTIVE


  ulWaitTimeOuter = 10;
  ulWaitTimeInner = 100000;
  uiLEDstate = LED_TXD_MESS_OFF;

  while(1) {

    if (uiLEDstate == (unsigned int) LED_TXD_MESS_ON) {
      OUT_TXD_MESS = LED_TXD_MESS_OFF; // LED "OFF"
      uiLEDstate = LED_TXD_MESS_OFF;
    } else {
      OUT_TXD_MESS = LED_TXD_MESS_ON;  // LED "ON"
      uiLEDstate = LED_TXD_MESS_ON;
    }

    // Wait ...
    for (ulWaitTimeOuter_Tmp = 0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++) {
      for (ulWaitTimeInner_Tmp = 0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++) {
      }
    }

  }

}

//===========================================================================
//
// Function    : LED_Switch
//
// Date        : 11.10.11
// Last update : 22.02.12
// This update : 23.10.12
//
// Description : LED ON (1) / OFF (0)
//
// Input       : -
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_Switch(unsigned int uiState)
{
  if (uiState != 1) {
    OUT_TXD_MESS = LED_TXD_MESS_OFF; // LED "OFF"
  } else {
    OUT_TXD_MESS = LED_TXD_MESS_ON;  // LED "ON"
  }
}

//===========================================================================
//
// Function    : LED_Signal
//
// Date        : 05.10.12
// Last update : 23.10.12
// This update : 06.12.12
//
// Description : LED signalisieren
//               > in dieser Funktion bleiben ... STOP ...
//
// Input       : unsigned long ulWaitTimeOuter
//               unsigned long ulWaitTimeInner
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_Signal(unsigned long ulWaitTimeOuter, unsigned long ulWaitTimeInner, unsigned int uiBlinkCnt)
{
unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;
unsigned int i;


//#ifdef TEST_LED_TXD_MESS_ACTIVE
  // ================================================================
  // Ausgang TXD_MESS für TEST-LED initialisieren
  // ================================================================
//  TRISBbits.TRISB12 = 0;        // Output RB12: TEST-LED an TXD_MESS => Pin 20
//#endif  // TEST_LED_TXD_MESS_ACTIVE


  stSystem.uiLEDerrState = uiBlinkCnt;

  while (1) {

    for (i=0; i<uiBlinkCnt; i++) {

      LED_Switch(1);  // LED "ON"
      // Wait SHORT ...
      for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++) {
        for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++) {
        }
      }
      LED_Switch(0);  // LED "OFF"
      // Wait SHORT ...
      for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++) {
        for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++) {
        }
      }

    }  // for (i=0; i<uiBlinkCnt; i++)

    // Wait LONG ...
    for (i=0; i<5; i++) {
      // Wait SHORT ...
      for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++) {
        for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++) {
        }
      }
    }  // for (i=0; i<5; i++)

  }  // while (1)

}

//===========================================================================
//
// Function    : LED_Toggle
//
// Date        : 11.10.11
// Last update : 22.02.11
// This update : 07.12.12
//
// Description : LED toggeln 
//
// Input       : -
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_Toggle(void) {

  if (stSystem.uiLEDdspState == (unsigned int) LED_TXD_MESS_ON) {
    OUT_TXD_MESS = LED_TXD_MESS_OFF; // LED "OFF"
    stSystem.uiLEDdspState = LED_TXD_MESS_OFF;
  } else {
    OUT_TXD_MESS = LED_TXD_MESS_ON; // LED "ON"
    stSystem.uiLEDdspState = LED_TXD_MESS_ON;
  }

}

//===========================================================================
//
// Function    : LED_ToggleAndStop
//
// Date        : 11.10.11
// Last update : 06.12.12
// This update : 07.12.12
//
// Description : LED toggeln 
//               > in dieser Funktion bleiben ... STOP ...
//
// Input       : unsigned long ulWaitTimeOuter
//               unsigned long ulWaitTimeInner
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_ToggleAndStop(unsigned long ulWaitTimeOuter, unsigned long ulWaitTimeInner) {

unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;


//#ifdef TEST_LED_TXD_MESS_ACTIVE
    // ================================================================
    // Ausgang TXD_MESS für TEST-LED initialisieren
    // ================================================================
//    TRISBbits.TRISB12 = 0; // Output RB12: TEST-LED an TXD_MESS => Pin 20
//#endif  // TEST_LED_TXD_MESS_ACTIVE


  LED_Toggle();

  while (1) {
    LED_Toggle();
    // Wait ...
    for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++) {
      for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++) {
      }
    }
  }

}

//===========================================================================
//
// Function    : LED_ToggleAndWait
//
// Date        : 11.10.11
// Last update : 06.12.12
// This update : 07.12.12
//
// Description : LED toggeln 
//               > mit Warteschleife ...
//
// Input       : unsigned long ulWaitTimeOuter
//               unsigned long ulWaitTimeInner
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_ToggleAndWait(unsigned long ulWaitTimeOuter, unsigned long ulWaitTimeInner) {

//unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;

//#ifdef TEST_LED_TXD_MESS_ACTIVE
    // ================================================================
    // Ausgang TXD_MESS für TEST-LED initialisieren
    // ================================================================
//    TRISBbits.TRISB12 = 0; // Output RB12: TEST-LED an TXD_MESS => Pin 20
//#endif  // TEST_LED_TXD_MESS_ACTIVE


  LED_Toggle();

  // Wait ...
  for (ulWaitTimeOuter_Tmp = 0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++) {
    for (ulWaitTimeInner_Tmp = 0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++) {
    }
  }

}

// ===================================================
//
// Function    : CalcChecksum
//
// Date        : 09.08.11
// Last update : 09.08.11
// This update : 09.08.11
//
// Description : Checksumme berechnen
//
// Aufbau des I2C-Master/Slave-Protokolls :
// 1. Byte / Index 2 : Länge  : 0x...
// 2. Byte / Index 2 : CMD... : 0x...
// 3. Byte / Index 3 : DATA-1 : 0x...
// 4. Byte / Index 4 : DATA-2 : 0x...
// m. Byte / Index n : DATA-m : 0x...
// n. Byte / Index n+1 : CHKSUM : 0x...  => XOR Byteweise ohne CHKSUM selbst
//
// Input       :
//
// Output      :
//
// Return      :
//
// ===================================================
unsigned char CalcChecksum(char* cpData, unsigned int uiDataLen) {
    unsigned int i;
    unsigned char ucChecksum = 0;
    char* cpDataTemp;

    // Checksumme berechnen ...
    cpDataTemp = cpData;
    ucChecksum = 0;
    for (i = 0; i < uiDataLen; i++) {
        ucChecksum ^= *cpDataTemp; // XOR byteweise
        cpDataTemp++;
    }
    return (ucChecksum);
}

#ifdef ADC_PER_DMA
//===========================================================================
//
// Function    : InitSamples
//
// Date        : 05.12.12
// Last update : 05.12.12
// This update : 05.12.12
//
// Description : ADC-Werte initialisieren,
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void InitSamples(unsigned int uiChannelNr)
{
  switch (uiChannelNr) {
    case ADC_CHANNEL_NR_PHU: // AN4 : AV_VOLT_PHASE_U
      Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_PHU, ADC_IDX_OFFSET_PHU);
      break;
    case ADC_CHANNEL_NR_PHV: // AN5 : AV_VOLT_PHASE_V
      Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_PHV, ADC_IDX_OFFSET_PHV);
      break;
    case ADC_CHANNEL_NR_PHW: // AN9 : AV_VOLT_PHASE_W
      Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_PHW, ADC_IDX_OFFSET_PHW);
      break;
    case ADC_CHANNEL_NR_CLV: // AN10 : AV_CURR_LOAD_V
      Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_CLV, ADC_IDX_OFFSET_CLV);
      break;
  }
}

//===========================================================================
//
// Function    : CheckFalseCnt
//
// Date        : 12.12.12
// Last update : 12.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               FehlerCounter checken ...
//               > Spannung Phase U/V/W
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void CheckFalseCnt(unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
  if (stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] >= PHASE_X_FALSE_CNT_MAX) {
    stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
    // PHASE_X = 0 V
    stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_03++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

  }
}

//===========================================================================
//
// Function    : SetDataZero
//
// Date        : 12.12.12
// Last update : 12.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               Daten zurücksetzen ...
//               > Spannung Phase U/V/W
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void SetDataZero(unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
  // PHASE_X = 0 V
  stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
  stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;

#ifdef TEST_TX_TESTDATA_SIG_ZERO_01
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_03++;
  }
#endif  // TEST_TX_TESTDATA_SIG_ZERO_01

}

//===========================================================================
//
// Function    : SelectSamples
//
// Date        : 05.12.12
// Last update : 07.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               suchen und markieren der Halb-Perioden ...
//               > Spannung Phase U/V/W
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void SelectSamples(struct st_Samples* pstSamples, unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
unsigned int *puiTmp_Read;
unsigned int *puiTmp_End;
unsigned int i, j;
unsigned int uiState;

long lX, lQ;
float fCalcVal, fSqrt;

  if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
    // Signal ist kleiner ~30 Hz
    InitSamples(uiChannelNr);
    stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;

#ifdef TEST_TX_TESTDATA_SIG_TRUE_01
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_01++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_01

    return;
  }


#ifdef TEST_TX_TESTDATA_SIM
  stActValue.uiTestData_03++;
#endif  // TEST_TX_TESTDATA_SIM


#ifdef TEST_TX_TESTDATA_SIG_FOUND
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_01++;
  }
#endif  // TEST_TX_TESTDATA_SIG_FOUND


  puiTmp_Read = pstSamples->puiSample_Start;
  puiTmp_End = pstSamples->puiSample_End;


  uiState = ERR_NONE;

  j = SAMP_BUFF_SIZE; // 96 Samples 

  // max. gesamtes SampleArray durchsuchen ...
  for (i = 0; i < j; i++) {

    switch (stADC.uiState[uiChannelIdx]) {

      //######################################################################
      case SIGNAL_RESET:
      //######################################################################
        // Übergang von negativ zu positiv wird gesucht
        if (*puiTmp_Read >  Adc_Maxhalf_Value[0]) {         // > ADC_MAXVALUE_HALF => Null-Linie
          stADC.uiState[uiChannelIdx] = SIGNAL_RESET_OVER_NULL;
        } 
        ///* HSP FIX - 03.08.2016: Ignore every other half wave -> Jumps get eliminated
        else {
            stADC.uiState[uiChannelIdx] = SIGNAL_RESET_UNDER_NULL;
        } // */

        stADC.uiStartIdx[uiChannelIdx] = 0;
        stADC.uiStopIdx[uiChannelIdx] = 0;
        pstSamples->uiSampleCnts = 0;
        stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
        break;

      //######################################################################
      case SIGNAL_RESET_UNDER_NULL:
      //######################################################################
        // Nulldurchgang von negativ zu positiv suchen ...
        if (*puiTmp_Read >=  Adc_Maxhalf_Value[0]) {
          pstSamples->puiAct_Start = puiTmp_Read;
          pstSamples->uiSampleCnts++;   // 1. Sample OVER_NULL
//>x1
          // 1. Wert
          if (*pstSamples->puiAct_Start >=  Adc_Maxhalf_Value[0]) {
            stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start -  Adc_Maxhalf_Value[0];
          } else {
            stADC.uiDeltaVal[uiChannelIdx] =  Adc_Maxhalf_Value[0] - *pstSamples->puiAct_Start;
          }
          stADC.lAddVal[uiChannelIdx] = 0;
//<x1
          stADC.uiState[uiChannelIdx] = SIGNAL_OVER_NULL;
        } else {
          if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
            // Signal ist kleiner ~30 Hz

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_01++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

            InitSamples(uiChannelNr);
            stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
            break;
          }
        }
        break;

      //######################################################################
      case SIGNAL_RESET_OVER_NULL:
      //######################################################################
        // Nulldurchgang von positiv zu negativ suchen ...
        if (*puiTmp_Read <=  Adc_Maxhalf_Value[0]) {
          pstSamples->puiAct_Start = puiTmp_Read;
          pstSamples->uiSampleCnts++;   // 1. Sample UNDER_NULL
//>x1
          // 1. Wert
          if (*pstSamples->puiAct_Start >=  Adc_Maxhalf_Value[0]) {
            stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start -  Adc_Maxhalf_Value[0];
          } else {
            stADC.uiDeltaVal[uiChannelIdx] =  Adc_Maxhalf_Value[0] - *pstSamples->puiAct_Start;
          }
          stADC.lAddVal[uiChannelIdx] = 0;
//<x1
          stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_NULL;
        } else {
          if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
            // Signal ist kleiner ~30 Hz

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_01++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

            InitSamples(uiChannelNr);
            stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
            break;
          }
        }
        break;

      //######################################################################
      case SIGNAL_OVER_NULL:
      //######################################################################
        if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
          // Signal ist kleiner ~30 Hz

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_02++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

          InitSamples(uiChannelNr);
          stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
          stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
          break;
        }
        // Nulldurchgang von positiv zu negativ suchen ...
        if (*puiTmp_Read <  Adc_Maxhalf_Value[0]) {

          // positive Halb-Periode gefunden ...

#ifdef TEST_TX_TESTDATA_SIG_FOUND
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_02++;
  }
#endif  // TEST_TX_TESTDATA_SIG_FOUND


          pstSamples->puiAct_End = puiTmp_Read;
          stADC.uiState[uiChannelIdx] = SIGNAL_OVER_END;
//>x3
          lX = (long) stADC.uiDeltaVal[uiChannelIdx] * (-1);
          lQ = lX * lX; // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...
//<x3

//>x4

          if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN) {  // 10
            // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
            // Samples darf nit "0" sein, da ansonsten Division durch "0" im Folgenden ...
//            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
            // PHASE_X = 0 V
            // FehlerCounter checken ...
            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            break;
          }

          fCalcVal = (float) pstSamples->uiSampleCnts;

#ifdef ADC_BIT_10
//          fSqrt = (sqrt((float)stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.52;     // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
          fSqrt = (sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.16; // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
#endif  // ADC_BIT_10

#ifdef ADC_BIT_12

          //    fSqrt = (sqrt((float)lAdd / fCalcVal)) * stSystem.fK_Factor_UVW;
          // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
          fSqrt = sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal);

#endif  // ADC_BIT_12
//<x4

//>x5
          //    2,77  ==>  208   :  400
          //    2,92  ==>  217,5 :  400
          //    3,10  ==>        :  400

          if (fSqrt < (float)PHASE_X_VALUE_CHECK) {  // 25.0 V : 3.0 = 8.33 V  ==> *10 wegen 1 Kommastelle und ohne Verstärkungsfaktor 3,0 !

#ifdef TEST_TX_TESTDATA_SIG_TRUE_01
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_02++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_01

            // FehlerCounter checken ...
//            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            // Signale "0" ..
            SetDataZero(uiChannelIdx, uiChannelNr);

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_01++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_01

            break;

// Spg. < 10 V
//Restart_ADC_SCANDATA(72);  // Anzeige : 72 * Wurzel 3 = 125

            // Interrupt-Input für Frequenz-Messung sperren,
            // ein Jittern am Int-Input könnte ansonsten das System lahm legen ...
            //      IEC1bits.INT1IE = 0;    // Disable INT1 Interrupt Service Routine

          } else {  // if (fSqrt < (float)PHASE_X_VALUE_CHECK)

            // 1 halbe Periode ...

            // Anzahl der Sampels ==> Frequenz ...

            if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN) {
              // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...

#ifdef TEST_TX_TESTDATA_SIG_TRUE_01
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_03++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_01

              // FehlerCounter checken ...
              CheckFalseCnt(uiChannelIdx, uiChannelNr);
              break;
            }


/*
        if (stADC.uiVOLT_PHU_FreqMeanActCnt_State == 0) {
            stADC.uiVOLT_PHU_FreqMeanActCnt_State = 1;
            stADC.ulVOLT_PHU_FreqMeanActCnt = (unsigned long) (pstSamples->uiSampleCnts >> 1); // 0,5 * x[n]
            stADC.ulVOLT_PHU_FreqMeanActCnt_LastValue = stADC.ulVOLT_PHU_FreqMeanActCnt; // Vergangenheitswert : 0,5 * x[n-1]
        } else {
            //=====================================================
            // gleitende Mittelwertbildung für FrequenzCounter ... (0,5 * x[n-1] ) + (0,5 * x[n])
            //=====================================================
            lX = (unsigned long) (pstSamples->uiSampleCnts >> 1); // 0,5 * x[n]
            stADC.ulVOLT_PHU_FreqMeanActCnt = stADC.ulVOLT_PHU_FreqMeanActCnt_LastValue + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
            stADC.ulVOLT_PHU_FreqMeanActCnt_LastValue = lX; // (0,5 * x[n-1] )
        }

        if ((unsigned long) pstSamples->uiSampleCnts < stADC.ulVOLT_PHU_FreqMeanActCnt) {
            ulTempVal = stADC.ulVOLT_PHU_FreqMeanActCnt - (unsigned long) pstSamples->uiSampleCnts;
        } else {
            ulTempVal = (unsigned long) pstSamples->uiSampleCnts - stADC.ulVOLT_PHU_FreqMeanActCnt;
        }
        if (ulTempVal > 4) {
            // Frequenz und Spg. nicht berechnen ...
            // ... da pstSamples->uiSampleCnts zu weit von den vorherigen entfernt ist ...
            return ERR_MEASURE_ADC_002;
        }
*/

            stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

            //=====================================================
            // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
            //=====================================================
            if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001) {
              // erste Initialisierung
              stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
            } else {

              lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
              stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )

            } // if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)

            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;


/*
if (stActValue.iVolt_PHASE_U_Eff > 200) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 888;
  stActValue.fFreq_PHASE_U = 88.8;
  return ERR_MEASURE_ADC_008;
}

if (stActValue.iVolt_PHASE_U_Eff < 100) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 999;
  stActValue.fFreq_PHASE_U = 99.9;
  return ERR_MEASURE_ADC_008;
}
*/

          } // if (fSqrt < (float)PHASE_X_VALUE_CHECK)
//<x5
        
          uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
          InitSamples(uiChannelNr);

        } else {
          // nächster gültiger Sample der Halbwelle ...
          pstSamples->uiSampleCnts++; // x. Sample OVER_NULL
//>x2
          //=====================================================
          // quadratische Mittelwertbildung einer Halb-Periode ...
          //=====================================================
          // alle bisher gesampelten Werte addieren ...
          lX = (long) *puiTmp_Read - (long)  Adc_Maxhalf_Value[0];
          lQ = lX * lX;    // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...
//<x2
        }
        break;

      //######################################################################
      case SIGNAL_UNDER_NULL:
      //######################################################################
        if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
          // Signal ist kleiner ~30 Hz

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_02++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

          InitSamples(uiChannelNr);
          stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
          stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
          break;
        }
        // Nulldurchgang von negativ zu positiv suchen ...
        if (*puiTmp_Read >  Adc_Maxhalf_Value[0]) {

          // negative Halb-Periode gefunden ...

#ifdef TEST_TX_TESTDATA_SIG_FOUND
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_03++;
  }
#endif  // TEST_TX_TESTDATA_SIG_FOUND

          pstSamples->puiAct_End = puiTmp_Read; // - 1;
          stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_END;

//>x3
          lX = (long) stADC.uiDeltaVal[uiChannelIdx];
          lQ = lX * lX; // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...
//<x3

//>x4
          if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN) {  // 10
            // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
            // Samples darf nit "0" sein, da ansonsten Division durch "0" im Folgenden ...
//            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
            // PHASE_X = 0 V
            // FehlerCounter checken ...
            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            break;
          }

          fCalcVal = (float) pstSamples->uiSampleCnts;

#ifdef ADC_BIT_10
//          fSqrt = (sqrt((float)stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.52;     // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
          fSqrt = (sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.16; // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
#endif  // ADC_BIT_10

#ifdef ADC_BIT_12

          //    fSqrt = (sqrt((float)lAdd / fCalcVal)) * stSystem.fK_Factor_UVW;
          // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
          fSqrt = sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal);

#endif  // ADC_BIT_12
//<x4

//>x5
          //    2,77  ==>  208   :  400
          //    2,92  ==>  217,5 :  400
          //    3,10  ==>        :  400

          if (fSqrt < (float)PHASE_X_VALUE_CHECK) {  // 25.0 V : 3.0 = 8.33 V  ==> *10 wegen 1 Kommastelle und ohne Verstärkungsfaktor 3,0 !

            // FehlerCounter checken ...
//            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            // Signale "0" ..
            SetDataZero(uiChannelIdx, uiChannelNr);

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
  if (uiChannelNr == ADC_CHANNEL_NR_PHU) {
    stActValue.uiTestData_02++;
  }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_01
            break;

// Spg. < 10 V
//Restart_ADC_SCANDATA(72);  // Anzeige : 72 * Wurzel 3 = 125

            // Interrupt-Input für Frequenz-Messung sperren,
            // ein Jittern am Int-Input könnte ansonsten das System lahm legen ...
            //      IEC1bits.INT1IE = 0;    // Disable INT1 Interrupt Service Routine

          } else {  // if (fSqrt < (float)PHASE_X_VALUE_CHECK)

            // 1 halbe Periode

            // Anzahl der Sampels ==> Frequenz ...

            if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN) {
              // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
              // FehlerCounter checken ...
              CheckFalseCnt(uiChannelIdx, uiChannelNr);
              break;
            }
            stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

            //=====================================================
            // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
            //=====================================================
            if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001) {
              // erste Initialisierung
              stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
            } else {

              lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
              stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )

            } // if ((stADC..uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)

            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;

/*
if (stActValue.iVolt_PHASE_U_Eff > 200) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 888;
  stActValue.fFreq_PHASE_U = 88.8;
  return ERR_MEASURE_ADC_008;
}

if (stActValue.iVolt_PHASE_U_Eff < 100) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 999;
  stActValue.fFreq_PHASE_U = 99.9;
  return ERR_MEASURE_ADC_008;
}
*/

          } // if (fSqrt < (float)PHASE_X_VALUE_CHECK)
//<x5

          uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
          InitSamples(uiChannelNr);

        } else {
          pstSamples->uiSampleCnts++; // x. Sample UNDER_NULL
//>x2
          //=====================================================
          // quadratische Mittelwertbildung einer Halb-Periode ...
          //=====================================================
          // alle bisher gesampelten Werte addieren ...
          lX = (long) *puiTmp_Read - (long)  Adc_Maxhalf_Value[0];
          lQ = lX * lX;    // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...
//<x2
        }
        break;

      //######################################################################
      default:
      //######################################################################
        // Error ...
        uiState = ERR_MEASURE_ADC_004; // falscher Stati bei der Suche nach einer Halbwelle ...
        InitSamples(uiChannelNr);
        break;

    } // switch (stADC.uiVOLT_PHU_State[stADC.uiVOLT_PHU_SelectIdx])


    if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
      // Signal ist kleiner ~30 Hz
      InitSamples(uiChannelNr);
      stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
      stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
      break;
    }

    if (uiState != ERR_NONE) {
      // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
      break;
    } else {

// Mehr Samples als erlaubt ...
// 40 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 40 Hz-Signal : max. 625 Samples ...
// somit : bei 96 Samples pro DMA-Interrupt, werden max. 7 DMA-Interrupts benötigt um eine ganze
// Periode zu sampeln. Für eine halbe Periode werden somit 4 DMA-Interrupts benötigt !
// 30 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 30 Hz-Signal : max. 833 Samples ...
// somit : bei 96 Samples pro DMA-Interrupt, werden max. 9 DMA-Interrupts benötigt um eine ganze
// Periode zu sampeln. Für eine halbe Periode werden somit 5 DMA-Interrupts benötigt !
// => somit sind 19,2 ms notwendig, um eine HalbPeriode für 4 Kanäle mit je 96 Samples pro DMA_Interrupt
//    und 10 µs Wandlungszeit pro Sample
//    ( (4*96) * 5 DMA-Interrupts ) * 10 µs ==> 19,2 ms
      if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
//        stActValue.iVolt_PHASE_U_Eff = 111;
//        stActValue.fFreq_PHASE_U = 11.1;
//        stADC.uiVOLT_PHU_State[uiArrayIdx] = SIGNAL_RESET;
//        pstSamples->puiProcess_WR_Act = pstSamples->puiProcess_WR_Start;
//        pstSamples->uiProcess_WR_State = 0;
        InitSamples(uiChannelNr);
        stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
        stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
        break;
      }

      // WEITER : nächste Leseadresse ... (WEITER For ...)
      puiTmp_Read++;  // zeigt jetzt auf PHV
      puiTmp_Read++;  // zeigt jetzt auf PHW
      puiTmp_Read++;  // zeigt jetzt auf CLV
      puiTmp_Read++;  // zeigt jetzt auf nächste PHU

      // Check auf Ende des DMA-Speichers : max 4*96 Samples ...
      if (puiTmp_Read > puiTmp_End) {
        // Suche beenden, da bisher beschriebenes DMA-Array-Ende erreicht ...
        // StartAdresse für nächsten Zyklus eintragen ...
        pstSamples->puiAct_End = puiTmp_End;
        uiState = ERR_MEASURE_ADC_005; // aktuell eingelesenes Array-Ende erreicht, bei der Suche nach einer Halbwelle ...
        // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
        break;
      }
      
    } // if (uiState != ERR_NONE)

  } // for (i=0; i<j; i++)

}

//===========================================================================
//
// Function    : SelectSamples_CLV
//
// Date        : 06.12.12
// Last update : 07.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               suchen und markieren der Halb-Perioden ...
//               > NUR STROM CURR_LOAD_V
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void SelectSamples_CLV(struct st_Samples* pstSamples, unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
unsigned int *puiTmp_Read;
unsigned int *puiTmp_End;
unsigned int i, j;
unsigned int uiState;

long lX, lQ;
float fCalcVal, fSqrt;


  puiTmp_Read = pstSamples->puiSample_Start;
  puiTmp_End = pstSamples->puiSample_End;

  // Berechnung des Laststromes ...
  // 3,0 V / 4096 ==>  0,7324218 mV pro Digit
  // 1 mV am ADC  ==>  1 mA Laststrom am Eingang der HW (ohne SHUNT !)
  // Laststrom am Eingang der HW in mA  ==>  Digits * 0,7324218 mV


/*
//> TEST
// Digits in mA umrechnen, für Einspeisung von Gleichstrom ...
  uiState = *puiTmp_Read;
  if (uiState >=  Adc_Maxhalf_Value[0]) {
    fCalcVal = (float) (uiState -  Adc_Maxhalf_Value[0]);
  } else {
    fCalcVal = (float) ( Adc_Maxhalf_Value[0] - uiState);
  }
  stActValue.iPhaseVal_Eff[uiChannelIdx] = (int) (fCalcVal * 7.324218f);  // 0,7324218 * 10, dann wird direkt mA angezeigt ...
  stActValue.fPhaseFreq[uiChannelIdx] = 12.3;
  return;
//< TEST
*/


  uiState = ERR_NONE;

  j = SAMP_BUFF_SIZE; // 96 Samples

  // max. gesamtes SampleArray durchsuchen ...
  for (i = 0; i < j; i++) {

    switch (stADC.uiState[uiChannelIdx]) {
      case SIGNAL_RESET:
        // Übergang von negativ zu positiv wird gesucht
        if (*puiTmp_Read >  Adc_Maxhalf_Value[0]) {         // > ADC_MAXVALUE_HALF => Null-Linie
          stADC.uiState[uiChannelIdx] = SIGNAL_RESET_OVER_NULL;
        }

        ///* HSP FIX - 03.08.2016: Ignore every other half wave -> Jumps get eliminated
        else {
          stADC.uiState[uiChannelIdx] = SIGNAL_RESET_UNDER_NULL;
        }// */
        stADC.uiStartIdx[uiChannelIdx] = 0;
        stADC.uiStopIdx[uiChannelIdx] = 0;
        pstSamples->uiSampleCnts = 0;
        stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
        break;

      case SIGNAL_RESET_UNDER_NULL:
        // Nulldurchgang von negativ zu positiv suchen ...
        if (*puiTmp_Read >=  Adc_Maxhalf_Value[0]) {
          pstSamples->puiAct_Start = puiTmp_Read;
          pstSamples->uiSampleCnts++;   // 1. Sample OVER_NULL
//>x1
          // 1. Wert
          if (*pstSamples->puiAct_Start >=  Adc_Maxhalf_Value[0]) {
            stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start -  Adc_Maxhalf_Value[0];
          } else {
            stADC.uiDeltaVal[uiChannelIdx] =  Adc_Maxhalf_Value[0] - *pstSamples->puiAct_Start;
          }
          stADC.lAddVal[uiChannelIdx] = 0;
//<x1
          stADC.uiState[uiChannelIdx] = SIGNAL_OVER_NULL;
        } else {
          if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
            // Signal ist kleiner ~30 Hz
            InitSamples(uiChannelNr);
            stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
            break;
          }
        }
        break;

      case SIGNAL_RESET_OVER_NULL:
        // Nulldurchgang von positiv zu negativ suchen ...
        if (*puiTmp_Read <=  Adc_Maxhalf_Value[0]) {
          pstSamples->puiAct_Start = puiTmp_Read;
          pstSamples->uiSampleCnts++;   // 1. Sample UNDER_NULL
//>x1
          // 1. Wert
          if (*pstSamples->puiAct_Start >=  Adc_Maxhalf_Value[0]) {
            stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start -  Adc_Maxhalf_Value[0];
          } else {
            stADC.uiDeltaVal[uiChannelIdx] =  Adc_Maxhalf_Value[0] - *pstSamples->puiAct_Start;
          }
          stADC.lAddVal[uiChannelIdx] = 0;
//<x1
          stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_NULL;
        } else {
          if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
            // Signal ist kleiner ~30 Hz
            InitSamples(uiChannelNr);
            stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
            break;
          }
        }
        break;

      case SIGNAL_OVER_NULL:
        if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
          // Signal ist kleiner ~30 Hz
          InitSamples(uiChannelNr);
          stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
          stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
          break;
        }
        // Nulldurchgang von positiv zu negativ suchen ...
        if (*puiTmp_Read <  Adc_Maxhalf_Value[0]) {
          pstSamples->puiAct_End = puiTmp_Read;
          stADC.uiState[uiChannelIdx] = SIGNAL_OVER_END;
          // Halb-Periode gefunden ...
//>x3
          lX = (long) stADC.uiDeltaVal[uiChannelIdx] * (-1);
          lQ = lX * lX; // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...
//<x3

//>x4
          if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN) {
            // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
            // Samples darf nit "0" sein, da ansonsten Division durch "0" im Folgenden ...
//            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
            // PHASE_X = 0 V
            // FehlerCounter checken ...
            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            break;
          }

          fCalcVal = (float) pstSamples->uiSampleCnts;

#ifdef ADC_BIT_10
//          fSqrt = (sqrt((float)stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.52;     // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
          fSqrt = (sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.16; // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
#endif  // ADC_BIT_10

#ifdef ADC_BIT_12

          //    fSqrt = (sqrt((float)lAdd / fCalcVal)) * stSystem.fK_Factor_UVW;
          // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
          fSqrt = sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal);

#endif  // ADC_BIT_12
//<x4

//>x5
          if (fSqrt < (float)CURR_LOAD_V_VALUE_CHECK) {  // 2.0 A ???

            // FehlerCounter checken ...
//            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            // Signale "0" ..
            SetDataZero(uiChannelIdx, uiChannelNr);

            break;

// Spg. < 10 V
//Restart_ADC_SCANDATA(72);  // Anzeige : 72 * Wurzel 3 = 125

            // Interrupt-Input für Frequenz-Messung sperren,
            // ein Jittern am Int-Input könnte ansonsten das System lahm legen ...
            //      IEC1bits.INT1IE = 0;    // Disable INT1 Interrupt Service Routine

          } else {  // if (fSqrt < (float)CURR_LOAD_V_VALUE_CHECK)

            // 1 halbe Periode ...

            // Anzahl der Sampels ==> Frequenz ...

            if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN) {
              // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
              // FehlerCounter checken ...
              CheckFalseCnt(uiChannelIdx, uiChannelNr);
              break;
            }

/*
        if (stADC.uiVOLT_PHU_FreqMeanActCnt_State == 0) {
            stADC.uiVOLT_PHU_FreqMeanActCnt_State = 1;
            stADC.ulVOLT_PHU_FreqMeanActCnt = (unsigned long) (pstSamples->uiSampleCnts >> 1); // 0,5 * x[n]
            stADC.ulVOLT_PHU_FreqMeanActCnt_LastValue = stADC.ulVOLT_PHU_FreqMeanActCnt; // Vergangenheitswert : 0,5 * x[n-1]
        } else {
            //=====================================================
            // gleitende Mittelwertbildung für FrequenzCounter ... (0,5 * x[n-1] ) + (0,5 * x[n])
            //=====================================================
            lX = (unsigned long) (pstSamples->uiSampleCnts >> 1); // 0,5 * x[n]
            stADC.ulVOLT_PHU_FreqMeanActCnt = stADC.ulVOLT_PHU_FreqMeanActCnt_LastValue + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
            stADC.ulVOLT_PHU_FreqMeanActCnt_LastValue = lX; // (0,5 * x[n-1] )
        }

        if ((unsigned long) pstSamples->uiSampleCnts < stADC.ulVOLT_PHU_FreqMeanActCnt) {
            ulTempVal = stADC.ulVOLT_PHU_FreqMeanActCnt - (unsigned long) pstSamples->uiSampleCnts;
        } else {
            ulTempVal = (unsigned long) pstSamples->uiSampleCnts - stADC.ulVOLT_PHU_FreqMeanActCnt;
        }
        if (ulTempVal > 4) {
            // Frequenz und Spg. nicht berechnen ...
            // ... da pstSamples->uiSampleCnts zu weit von den vorherigen entfernt ist ...
            return ERR_MEASURE_ADC_002;
        }
*/

            stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

            //=====================================================
            // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
            //=====================================================
            if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001) {
              // erste Initialisierung
              stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
            } else {

              lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
              stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )

            } // if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)

            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;


/*
if (stActValue.iVolt_PHASE_U_Eff > 200) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 888;
  stActValue.fFreq_PHASE_U = 88.8;
  return ERR_MEASURE_ADC_008;
}

if (stActValue.iVolt_PHASE_U_Eff < 100) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 999;
  stActValue.fFreq_PHASE_U = 99.9;
  return ERR_MEASURE_ADC_008;
}
*/

          } // if (fSqrt < (float)CURR_LOAD_V_VALUE_CHECK)
//<x5

          uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
          InitSamples(uiChannelNr);

        } else {
          // nächster gültiger Sample der Halbwelle ...
          pstSamples->uiSampleCnts++; // x. Sample OVER_NULL
//>x2
          //=====================================================
          // quadratische Mittelwertbildung einer Halb-Periode ...
          //=====================================================
          // alle bisher gesampelten Werte addieren ...
          lX = (long) *puiTmp_Read - (long)  Adc_Maxhalf_Value[0];
          lQ = lX * lX;    // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...
//<x2
        }
        break;

      case SIGNAL_UNDER_NULL:
        if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
          // Signal ist kleiner ~30 Hz
          InitSamples(uiChannelNr);
          stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
          stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
          break;
        }
        // Nulldurchgang von negativ zu positiv suchen ...
        if (*puiTmp_Read >  Adc_Maxhalf_Value[0]) {
          pstSamples->puiAct_End = puiTmp_Read; // - 1;
          stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_END;
          // Halb-Periode gefunden ...
//>x3
          lX = (long) stADC.uiDeltaVal[uiChannelIdx];
          lQ = lX * lX; // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...
//<x3

//>x4
          if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN) {
            // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
            // Samples darf nit "0" sein, da ansonsten Division durch "0" im Folgenden ...
//            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
            // PHASE_X = 0 V
            // FehlerCounter checken ...
            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            break;
          }

          fCalcVal = (float) pstSamples->uiSampleCnts;

#ifdef ADC_BIT_10
//          fSqrt = (sqrt((float)stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.52;     // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
          fSqrt = (sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.16; // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
#endif  // ADC_BIT_10

#ifdef ADC_BIT_12

          //    fSqrt = (sqrt((float)lAdd / fCalcVal)) * stSystem.fK_Factor_UVW;
          // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
          fSqrt = sqrt((float) stADC.lAddVal[uiChannelIdx] / fCalcVal);

#endif  // ADC_BIT_12
//<x4

//>x5
          if (fSqrt < (float)CURR_LOAD_V_VALUE_CHECK) {  // 2.0 A ???

            // FehlerCounter checken ...
//            CheckFalseCnt(uiChannelIdx, uiChannelNr);
            // Signale "0" ..
            SetDataZero(uiChannelIdx, uiChannelNr);
            break;


// Spg. < 10 V
//Restart_ADC_SCANDATA(72);  // Anzeige : 72 * Wurzel 3 = 125

            // Interrupt-Input für Frequenz-Messung sperren,
            // ein Jittern am Int-Input könnte ansonsten das System lahm legen ...
            //      IEC1bits.INT1IE = 0;    // Disable INT1 Interrupt Service Routine

          } else {  // if (fSqrt < (float)CURR_LOAD_V_VALUE_CHECK)

            // 1 halbe Periode

            // Anzahl der Sampels ==> Frequenz ...

            if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN) {
              // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
              // FehlerCounter checken ...
              CheckFalseCnt(uiChannelIdx, uiChannelNr);
              break;
            }

            stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

            //=====================================================
            // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
            //=====================================================
            if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001) {
              // erste Initialisierung
              stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
            } else {

              lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
              stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
              stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )

            } // if ((stADC..uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)

            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;

/*
if (stActValue.iVolt_PHASE_U_Eff > 200) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 888;
  stActValue.fFreq_PHASE_U = 88.8;
  return ERR_MEASURE_ADC_008;
}

if (stActValue.iVolt_PHASE_U_Eff < 100) {
  // Fehler, da Samples mehr als 1000 gefunden ...
  // ... somit 1000 * 50 µs = 20 Hz
  stActValue.iVolt_PHASE_U_Eff = 999;
  stActValue.fFreq_PHASE_U = 99.9;
  return ERR_MEASURE_ADC_008;
}
*/

          } // if (fSqrt < (float)CURR_LOAD_V_VALUE_CHECK)
//<x5

          uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
          InitSamples(uiChannelNr);

        } else {
          pstSamples->uiSampleCnts++; // x. Sample UNDER_NULL
//>x2
          //=====================================================
          // quadratische Mittelwertbildung einer Halb-Periode ...
          //=====================================================
          // alle bisher gesampelten Werte addieren ...
          lX = (long) *puiTmp_Read - (long)  Adc_Maxhalf_Value[0];
          lQ = lX * lX;    // X hoch 2
          stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...
//<x2
        }
        break;

      default:
        // Error ...
        uiState = ERR_MEASURE_ADC_004; // falscher Stati bei der Suche nach einer Halbwelle ...
        InitSamples(uiChannelNr);
        break;

    } // switch (stADC.uiVOLT_PHU_State[stADC.uiVOLT_PHU_SelectIdx])


    if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
      // Signal ist kleiner ~30 Hz
      InitSamples(uiChannelNr);
      stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
      stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
      break;
    }

    if (uiState != ERR_NONE) {
      // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
      break;
    } else {

// Mehr Samples als erlaubt ...
// 40 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 40 Hz-Signal : max. 625 Samples ...
// somit : bei 96 Samples pro DMA-Interrupt, werden max. 7 DMA-Interrupts benötigt um eine ganze
// Periode zu sampeln. Für eine halbe Periode werden somit 4 DMA-Interrupts benötigt !
// 30 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 30 Hz-Signal : max. 833 Samples ...
// somit : bei 96 Samples pro DMA-Interrupt, werden max. 9 DMA-Interrupts benötigt um eine ganze
// Periode zu sampeln. Für eine halbe Periode werden somit 5 DMA-Interrupts benötigt !
// => somit sind 19,2 ms notwendig, um eine HalbPeriode für 4 Kanäle mit je 96 Samples pro DMA_Interrupt
//    und 10 µs Wandlungszeit pro Sample
//    ( (4*96) * 5 DMA-Interrupts ) * 10 µs ==> 19,2 ms
      if (pstSamples->uiSampleCnts >= 833) {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
//        stActValue.iVolt_PHASE_U_Eff = 111;
//        stActValue.fFreq_PHASE_U = 11.1;
//        stADC.uiVOLT_PHU_State[uiArrayIdx] = SIGNAL_RESET;
//        pstSamples->puiProcess_WR_Act = pstSamples->puiProcess_WR_Start;
//        pstSamples->uiProcess_WR_State = 0;
        InitSamples(uiChannelNr);
        stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
        stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
        break;
      }

      // WEITER : nächste Leseadresse ... (WEITER For ...)
      puiTmp_Read++;  // zeigt jetzt auf PHV
      puiTmp_Read++;  // zeigt jetzt auf PHW
      puiTmp_Read++;  // zeigt jetzt auf CLV
      puiTmp_Read++;  // zeigt jetzt auf nächste PHU

      // Check auf Ende des DMA-Speichers : max 4*96 Samples ...
      if (puiTmp_Read > puiTmp_End) {
        // Suche beenden, da bisher beschriebenes DMA-Array-Ende erreicht ...
        // StartAdresse für nächsten Zyklus eintragen ...
        pstSamples->puiAct_End = puiTmp_End;
        uiState = ERR_MEASURE_ADC_005; // aktuell eingelesenes Array-Ende erreicht, bei der Suche nach einer Halbwelle ...
        // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
        break;
      }

    } // if (uiState != ERR_NONE)

  } // for (i=0; i<j; i++)

}
#endif  // ADC_PER_DMA


//===========================================================================
//
// Function    : ConvertToDecimal
//
// Date        : 07.02.09
// Last update : 07.02.09
// This update : 12.05.09
//
// Description : A positive long integer is convertet into up to 10 decimal
//               digits. The result is returned in an array of given length.
//               The function accepts only positve values and no overflow
//               is detected, therefore the user has to care for this.
//
// Input       : - ULONG ulValue : positive binary value
//               - UCHAR aData[] : array to contain the decimal result
//               - UCHAR ucLength: maximum length of the decimal value
//
// Output      : - UCHAR aData[] : array of converted data
//
// Return      : -
//
//===========================================================================
void ConvertToDecimal(unsigned long ulValue, unsigned char aData[], unsigned char ucLength) {
    unsigned char aBuffer[10], ucIdx;

    // initialize buffer
    ucIdx = sizeof (aBuffer);
    while (ucIdx--)
        aBuffer[ucIdx] = 0;

    // 10^9
    while (ulValue >= 1000000000) {
        ulValue -= 1000000000;
        aBuffer[9] += 1;
    }
    // 10^8
    while (ulValue >= 1000000) {
        ulValue -= 100000000;
        aBuffer[8] += 1;
    }
    // 10^7
    while (ulValue >= 10000000) {
        ulValue -= 10000000;
        aBuffer[7] += 1;
    }
    // 10^6
    while (ulValue >= 1000000) {
        ulValue -= 1000000;
        aBuffer[6] += 1;
    }
    // 10^5
    while (ulValue >= 100000) {
        ulValue -= 100000;
        aBuffer[5] += 1;
    }
    // 10^4
    while (ulValue >= 10000) {
        ulValue -= 10000;
        aBuffer[4] += 1;
    }
    // 10^3
    while (ulValue >= 1000) {
        ulValue -= 1000;
        aBuffer[3] += 1;
    }
    // 10^2
    while (ulValue >= 100) {
        ulValue -= 100;
        aBuffer[2] += 1;
    }
    // 10^1
    while (ulValue >= 10) {
        ulValue -= 10;
        aBuffer[1] += 1;
    }
    // 10^0
    aBuffer[0] = ulValue;

    while (ucLength--)
        aData[ucLength] = aBuffer[ucLength];
}

//===========================================================================
//
// Function    : CheckSwReset
//
// Date        : 25.09.12
// Last update : 25.09.12
// This update : 25.09.12
//
// Description : Software-RESET durchführen
//               ausgelöst per SLAVE-2
//
// Input       :
//
// Output      :
//
// Return      :
//
//===========================================================================
void CheckSwReset(void)
{

#ifdef DIRECT_MEASURE_SLAVE_IO_ACTIVE

  Read_SlaveInput_3(1);

#ifdef UART1_ACTIVE

#ifdef MANUELL_RESET

  if ( (stSystem.uiInit & INIT_M_MEASURE) == INIT_M_MEASURE) {

    if (stUART1.stUART.ucTxStart == 1) {  // wird immer 640 ms nach RESET gesetzt ...

      // Check des Signals der Kommunikation mit SLAVE ...
      if ( (stIO.ucSlaveInput & STATE_PER_CON_MESS_3_R) == STATE_PER_CON_MESS_3_R) {
        // SW-Reset der MEASURE-CPU
        DoSWReset();
      }

    }  // if (stUART1.stUART.ucTxStart == 1)

  }  // if ( (stSystem.uiInit & INIT_M_MEASURE) == INIT_M_MEASURE)

#endif  // MANUELL_RESET

/*
#ifdef UART1_ACTIVE

    if ( ( (stSystem.uiInit & INIT_M_MEASURE) == INIT_M_MEASURE) &&
           (stUART1.stUART.ucTxStart == 1) ) {  // wird immer 640 ms nach RESET gesetzt ...

      Read_SlaveInput_3();

      // Check des Signals der Kommunikation mit SLAVE ...
      if ( (stIO.ucSlaveInput & STATE_PER_CON_MESS_3_R) == STATE_PER_CON_MESS_3_R) {
        // SW-Reset der MEASURE-CPU
        DoSWReset();
      }

    }
*/




    // Reset-Signal an SLAVE, dass MEASURE einen "Reset" durchgeführt hat, wieder zurücksetzen ...
    // siehe hierzu unter ==> 640 ms Zeittakt
//    Write_SlaveOutput_2(PER_CON_MESS_OFF);    // PER_CON_MESS_2_R

 /*
    if ( (stSystem.uiInit & INIT_M_UART1) == INIT_M_UART1) {

      // Kommunikation mit SLAVE ist gestört ...
      // also UART-1 erneut initialisieren ..
      if (stUART1.uiReInit == 0) {
        // UART-1 initialisieren ...
        Init_UART1();
        uibitUART1.Activ = BIT_TRUE;     // UART1 freigegeben ...
        stUART1.uiReInit = 1;
      }

    }

  } else {
    stUART1.uiReInit = 0;
  }
*/


#endif  // UART1_ACTIVE
#endif  // DIRECT_MEASURE_SLAVE_IO_ACTIVE

}
