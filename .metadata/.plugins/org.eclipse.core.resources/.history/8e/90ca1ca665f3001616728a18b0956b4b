#include "MyComplex.hpp"

MyComplex::MyComplex(double R, double I)
{
    Im = I;
    Re = R;
}

MyComplex::MyComplex(double R)
{
    Im = 0.0f;
    Re = R;
}

MyComplex::MyComplex()
{
    Im = 0.0f;
    Re = 0.0f;
}

MyComplex::MyComplex(const MyComplex &c)
{
    this->Re=c.Re;
    this->Im=c.Im;
}

MyComplex::~MyComplex()
{

}

float MyComplex::GetIm()
{
    return Im;
}

float MyComplex::GetRe()
{
    return Re;
}

float MyComplex::SetIm(double I)
{
    Im = I;
}
float MyComplex::SetRe(double R)
{
    Re = R;
}

MyComplex MyComplex::operator + (MyComplex c)
{
    MyComplex Result;
    Result.Im = Im + c.Im;
    Result.Re = Re + c.Re;
    return Result;
}

MyComplex MyComplex::operator = (MyComplex c)
{
    Re = c.Re;
    Im = c.Im;
    return *this;
}

MyComplex Add(MyComplex a, MyComplex b)
{
    MyComplex Result;
    Result.Im = a.GetIm() + b.GetIm();
    Result.Re = a.GetRe() + b.GetRe();
    return Result;
}

//MyComplex MyComplex::Sub(MyComplex a, MyComplex b)
//{
//    MyComplex Result;
//    Result.Im = a.Im - b.Im;
//    Result.Re = a.Re - b.Re;
//    return Result;
//}
//
//MyComplex MyComplex::Mult(MyComplex a, MyComplex b)
//{
//    MyComplex Result;
//    Result.Re = (b.Re*a.Re - a.Im*b.Im);
//    Result.Im = (a.Re * b.Im + a.Im*b.Re);
//    return Result;
//}
//
//MyComplex MyComplex::Div(MyComplex a, MyComplex b)
//{
//    float div = (b.Re*b.Re) + (b.Im*b.Im);
//    MyComplex Result;
//    Result.Re = (a.Re*b.Re)+(a.Im*b.Im);
//    Result.Re /= div;
//    Result.Im = (a.Im*b.Re)-(a.Re*b.Im);
//    Result.Im /= div;
//    return Result;
//}
