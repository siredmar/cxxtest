//**********************************************************************************************
// Modulname: PROFIBUS.c	
//**********************************************************************************************
//
// Messumformer  - MUF
//
// Bearbeiter: Philipp Compensis
// Firma: HSS Barschat & Krönert GBR
// Tel.:  09129 28520
//
// 
//**********************************************************************************************

/*****************************************************************************/
/* include hierarchy */

#include "MUF.H"
#include "MUF.glb"
#include "EEPROM.h" 
#include "..\profibus\dp_inc\platform.h"
#include "..\profibus\dp_inc\dp_inc.h"
#include <string.h> //für memcpy //PC
#include "mathematik_modul.h" //Für Struct Berechung
#include "LPC24xx_enet.h"
#include "filter.h"


//*************************  Funktions-Prototypen  *****************************
void SetParameterModus2Speichern();
void 	Delay(u32_t t);

/*---------------------------------------------------------------------------*/
/* defines, structures                                                       */
/*---------------------------------------------------------------------------*/
// -- defines for user state
#define USER_STATE_CLEAR            ((UBYTE)0x00)
#define USER_STATE_RUN              ((UBYTE)0x01)
// -- defines for diagnostics
#define USER_TYPE_CFG_OK            ((UBYTE)0xFD)
#define USER_TYPE_APPL_RDY          ((UBYTE)0xFF)
// -- defines for cfg
#define SET_DATA_LENGT_INPUT			((UBYTE)0x10)
#define SET_DATA_LENGT_OUTPUT			((UBYTE)0x20)
#define SET_DATA_LENGT_INOUTPUT			((UBYTE)0x10)
#define CONSISTENCY_OVER_WHOLE_LENGTH	((UBYTE)0x80)

#pragma pack(1) // pragma pack, damit kein Alignment durchgeführt wird
typedef struct
{
	CFG_STRUCT  sCfgData;
	UBYTE       abInput[DIN_BUFSIZE];   //(Data Slave to Master) muss mit der Größe von DIN_BUFSIZE übereinstimmen
	UBYTE       abOutput[DOUT_BUFSIZE]; //(Data Master to Slave) muss mit der Größe von DOUT_BUFSIZE übereinstimmen
} __attribute__((packed)) USER_STRUC;
#pragma pack()

/*---------------------------------------------------------------------------*/
/* global user data definitions                                              */
/*---------------------------------------------------------------------------*/
VPC3_STRUC_PTR             pVpc3;               // pointer to Vpc3 structure
//__no_init VPC3_STRUC_PTR             pVpc3;               // pointer to Vpc3 structure //PC
VPC3_STRUC_PTR             pVpc3Channel1;       // pointer to Vpc3 structure channel 1
//__no_init VPC3_STRUC_PTR             pVpc3Channel1;       // pointer to Vpc3 structure channel 1 //PC

VPC3_ADR                   Vpc3AsicAddress;     // global asic address

VPC3_SYSTEM_STRUC_PTR      pDpSystem;           // global system structure
VPC3_SYSTEM_STRUC          sDpSystemChannel1;   // global system structure

VPC3_STRUC_ERRCB           sVpc3Error;          // error structure
USER_STRUC                 sUser;               // user structure


ROMCONST__ UBYTE NAME[12] = PRFIBUS_DEVICE_NAME;

/* v.1.20 - wird später abhänig vom Modus gesetzt
//Neue configuration für MUF
#define USER_CFG_DATA_LENGTH CFG_BUFSIZE

#if ((DOUT_BUFSIZE == 0x00) | (DOUT_BUFSIZE > 0x3F))
	#error Ungültige Größe von DOUT_BUFSIZE (für diese Konfiguration).
#endif
#define OUTPUT_DATA_LENTH	 (DOUT_BUFSIZE - 1)

#if ((DIN_BUFSIZE == 0x00) | (DIN_BUFSIZE > 0x3F))
	#error Ungültige Größe von DIN_BUFSIZE (für diese Konfiguration).
#endif
#define INPUT_DATA_LENTH	 (DIN_BUFSIZE - 1)

#define CFG1	0xC0 //0xC0 == it follows 1 length byte for outputs and 1 length byte for inputs
#define CFG2	CONSISTENCY_OVER_WHOLE_LENGTH | OUTPUT_DATA_LENTH
#define CFG3	CONSISTENCY_OVER_WHOLE_LENGTH | INPUT_DATA_LENTH
const UBYTE DefCfg[CFG_BUFSIZE] = { CFG1, CFG2, CFG3};
*/

/*---------------------------------------------------------------------------*/
/* function prototypes                                                       */
/*---------------------------------------------------------------------------*/



/*******************************************************************************
* SetEMCInit
*
* Funktion zum Initialisieren des EMC (xternal Memory Controllers) für den
* Zugriff auf den Profibus Bausteins
*******************************************************************************/
void SetEMCInit()
{
	u8_t	i;
	
	//Power Control for Peripherals register 
	SET_REGISTER_BITS(PCONP, PCONP_PCEMC, 1);
    
	//Funktion der Pins festlegen (Pin Function Select register)
	SET_REGISTER_BITS(PINSEL9, PINSEL9_P4_24, 0x1);	// 01 --> P4[24] = NOE
	SET_REGISTER_BITS(PINSEL9, PINSEL9_P4_26, 0x1);	// 01 --> P4[26] = BLS0
	SET_REGISTER_BITS(PINSEL9, PINSEL9_P4_30, 0x1);  // 01 --> P4[30] = NCS0	
	
	PINSEL8 &= BIN32(11111111,00000000,00000000,00000000); //Cler Bits 0 to 23
    PINSEL8 |= BIN32(00000000,01010101,01010101,01010101); //Set Bits 0 to 23 --> P4[0] bis P4[11] = A0 bis 11
	
	PINSEL6 &= BIN32(11111111,11111111,00000000,00000000); //Cler Bits 0 to 15
    PINSEL6 |= BIN32(00000000,00000000,01010101,01010101); //Set Bits 0 to 15 --> P4[0] bis P4[7] = D0 bis 7
	
	//Program the delay from the chip select to the read access
	EMCStaticWaitRd0 = 8-1; // 8 x 72 MHz --> 111,11 ns
	
	//Program the delay from the chip select to the write access
	EMCStaticWaitWr0 = 6-1; // 6 x 72 MHz --> 83,3 ns
	
	//EMC Control register
	SET_REGISTER_BITS(EMCControl, EMCControl_E, 1); //Enable
	SET_REGISTER_BITS(EMCControl, EMCControl_M, 0); //Normal mamory map (CS1 is not mirroed onto CS0)

	
	//*************  HW-Reset des PC3+CLF3 PROFIBUS-Baustein ************* 
	PROFIBUS_RESET_PIN_INIT();
	PROFIBUS_RESET_PIN_HIGH(); //Reset
	
	//kleine Pause (Mindestlänge 21ns)
	for(i=0xFF; i>0; i--){} //--> ca. 35ns
	
	PROFIBUS_RESET_PIN_LOW(); //Not Reset

}
/*******************************************************************************
* ENDE SetEMCInit
*******************************************************************************/

/*******************************************************************************
* SetProfibusModus1
*
* Funktion um jeweils abwechselnd neue Daten für den Profibus zu setzen und
* die Profibus-IRQ-Leitung zu pollen oder die ProfibusMain aufzurufen.
*******************************************************************************/
void SetProfibusModus1(struct MESSWERTE_STRUCT *messwerte, u8_t fehler_byte)
{	
	static BOOLEAN toggle = 1;

    //Zeiger auf die Daten vom MUF zum Master
    struct DATENFRAME_STRUCT *datenframe = (struct DATENFRAME_STRUCT *)&sUser.abInput[0];
	
	//Mit jedem Aufruf abwechselnd
	//entweder:
	if(toggle)
	{
		//Die Daten für den Profibus akualisieren
		//(Einzeln Kopieren geht schneller als mit memcpy)
		datenframe->dc1 = messwerte->dc1;
		datenframe->dc2 = messwerte->dc2;
		datenframe->dc3 = messwerte->dc3;
	
		datenframe->fehler_byte = fehler_byte;

#ifdef MIT_LIFEBIT
        //V.3.1.3 - lifebit togglen
        datenframe->konfigurations_byte ^= LIFEBIT_MASK;
#endif
		
		//An ProfibusMain melden dass neue Werte vorliegen
		pDpSystem->wEvent |= VPC3_EV_NEW_INPUT_DATA;  
		
		//Profibus-IRQ-Leitung pollen
		if(PROFIBUS_IRQ_PIN == PROFIBUS_IRQ) //Überprüfen ob ein IRQ vom PROFIBUS-Chip gemeldet wird ...
			VPC3_Isr();	//... und ggf. Die ISR des PROFIBUS-Treibers aufrufen
	}
	//oder:
	else
	{	
		ProfibusMain(); //call ProfibusMain() cyclically so that the PROFIBUS DP slave services can be processed.
	}
	toggle = !toggle;	
}	
/*******************************************************************************
* ENDE SetProfibusModus1
*******************************************************************************/

/*******************************************************************************
* SetProfibusModus2
*
* Funktion um im Modus 2 des MUFs neue Daten für den Profibus zu setzen und
* die ProfibusMain aufzurufen.
*******************************************************************************/
void SetProfibusModus2(struct  BERECHNUNG       *berechnung, 
                         struct  MESSWERTE_STRUCT *messwerte, 
                         float                    frequenz, 
                         float                    fcomp,
                         u8_t                     fehler_byte, 
                         int16_t                  info,
                         BOOLEAN                  fcomp_bildung_gestoert, 
                         BOOLEAN                  fcomp_schwelle_unterschritten,
                         float                    fcomp_gefiltert,      //V.2.3.1
                         float                    p_gefiltert,          //V.3.0.1
                         struct ALPHA_BETA        *alfa_beta)
{	
    //Zeiger auf die Daten vom MUF zum Master
    struct DATENFRAME_MODUS2_STRUCT *datenframe = (struct DATENFRAME_MODUS2_STRUCT *)&sUser.abInput[0];
	
	//Die Daten für den Profibus akualisiere
	//(Einzeln Kopieren geht schneller als mit memcpy)
    datenframe->i_eff       = berechnung->i_gen_eff;
    datenframe->u_eff       = berechnung->u_gen_eff;
    datenframe->p           = berechnung->p_gen;

	datenframe->dc1         = messwerte->dc1; //I1 DC
	datenframe->dc2         = messwerte->dc2; //I2 DC
	datenframe->dc3         = messwerte->dc3; //U DC

	datenframe->fehler_byte = fehler_byte;
	datenframe->info        = info;

    datenframe->q           = berechnung->q_gen;
    datenframe->s           = berechnung->s_gen;
    datenframe->cosphi      = berechnung->cosphi_gen;
    datenframe->f           = frequenz;
    datenframe->fcomp       = fcomp;
    datenframe->status_fcomp_berechnung.fcomp_bildung_gestoert        = fcomp_bildung_gestoert;
    datenframe->status_fcomp_berechnung.fcomp_schwelle_unterschritten = fcomp_schwelle_unterschritten;

    datenframe->fcomp_gefiltert = fcomp_gefiltert;  //V.2.3.1

    datenframe->p_gefiltert     = p_gefiltert;      //V.3.0.1

    datenframe->alpha_beta.ia   = alfa_beta->ia;
    datenframe->alpha_beta.ib   = alfa_beta->ib;
    datenframe->alpha_beta.ua   = alfa_beta->ua;

    datenframe->alpha_beta.ub   = alfa_beta->ub;

#ifdef MIT_LIFEBIT
    //V.3.1.3 - lifebit togglen
    datenframe->konfigurations_byte ^= LIFEBIT_MASK;
#endif
		
	//An ProfibusMain melden dass neue Werte vorliegen
	pDpSystem->wEvent |= VPC3_EV_NEW_INPUT_DATA;  
		
	//Profibus-IRQ-Leitung pollen
	if(PROFIBUS_IRQ_PIN == PROFIBUS_IRQ) //Überprüfen ob ein IRQ vom PROFIBUS-Chip gemeldet wird ...
			VPC3_Isr();	//... und ggf. Die ISR des PROFIBUS-Treibers aufrufen

    // ProfibusMain aufrufen
	ProfibusMain(); //call ProfibusMain() cyclically so that the PROFIBUS DP slave services can be processed.

}	
/*******************************************************************************
* ENDE SetProfibusModus2
*******************************************************************************/

/*******************************************************************************
* SetConfigByteProfibus
*
* Funktion zum Setzen des Konfigurationsbyte welches mit den anderen Daten mit
* übertragen wird
*******************************************************************************/
void SetConfigByteProfibus(u8_t config_byte)
{	
    //Zeiger auf die Daten vom MUF zum Master
    struct DATENFRAME_STRUCT *datenframe = (struct DATENFRAME_STRUCT *)&sUser.abInput[0];

	datenframe->konfigurations_byte = config_byte;
}	
/*******************************************************************************
* ENDE SetConfigByteProfibus
*******************************************************************************/


/*---------------------------------------------------------------------------*/
/* function: UserAlarm ( is also called from alarm state machine !!!! )      */
/*---------------------------------------------------------------------------*/
UBYTE UserAlarm( UBYTE bAlarmType, UBYTE bCheckDiagFlag )
{
	//MEM_UNSIGNED8_PTR 	pbToDiagArray;
	UBYTE           	bRetValue;
	UBYTE          		bExtDiagFlag;
	UBYTE           	bDiagLength;
	UBYTE           	bError;
	UWORD           	wDiagEvent;

   bRetValue = 0x00;

   wDiagEvent = (UWORD)bAlarmType;

   //don't send diagnostic twice!
   if(    ( wDiagEvent  != pDpSystem->wOldDiag  ) && ( FALSE == pDpSystem->bUserDiagActive )    )
   {
      //memset( &pDpSystem->abUserDiagnostic[0], 0x00, sizeof( pDpSystem->abUserDiagnostic ) );
	  memset( (void *)&pDpSystem->abUserDiagnostic[0], 0x00, sizeof( pDpSystem->abUserDiagnostic ) ); //PC
      //pbToDiagArray = pDpSystem->abUserDiagnostic;

      switch( bAlarmType )
      {
         case USER_TYPE_CFG_OK:
         {
            bExtDiagFlag = STAT_DIAG_SET;
            bExtDiagFlag = 0x00;
            bDiagLength = 0x00;
            break;
         }//case USER_TYPE_CFG_OK:

         case USER_TYPE_APPL_RDY:
         default:
         {
            bExtDiagFlag = 0x00;
            bDiagLength = 0x00;
            break;
         }//default:
      }//switch( bAlarmType )

      pDpSystem->bUserDiagActive = TRUE;

      bError = VPC3_SetDiagnosis( pDpSystem->abUserDiagnostic, bDiagLength, bExtDiagFlag, bCheckDiagFlag );

      if( bError == DP_OK )
      {
         pDpSystem->wOldDiag = wDiagEvent;

         bRetValue = DP_OK;
      }//if( bError == DP_OK )
      else
      {
         pDpSystem->bUserDiagActive = FALSE;
		 
         bRetValue = bError;
      }//else of if( bError == DP_OK )
   }//if(    ( wDiagEvent  != pDpSystem->wOldDiag  ) ...

   return bRetValue;
}//UBYTE UserAlarm( UBYTE bAlarmType, UBYTE bCheckDiagFlag )

/*--------------------------------------------------------------------------*/
/* function: ApplicationReady                                               */
//
// Wird z.B. aufgerufen wenn sich der Master verbindet //PC
/*--------------------------------------------------------------------------*/
void ApplicationReady( void )
{
   //reset Diag.Stat
   if( UserAlarm( USER_TYPE_APPL_RDY, FALSE ) == DP_OK )
   {
      pDpSystem->wEvent &= ~VPC3_EV_NEW_CFG_DATA;    // clear event
      pDpSystem->bApplicationReady = TRUE;
   }//if( UserAlarm( USER_TYPE_APPL_RDY, FALSE ) == DP_OK )
   
}//void ApplicationReady( void )

/*---------------------------------------------------------------------------*/
/* function: InitProfibus                                                    */
/*---------------------------------------------------------------------------*/
/*!
  \brief Initializing of PROFIBUS slave communication.
*/
void InitProfibus( void )
{
    #define USER_CFG_DATA_LENGTH CFG_BUFSIZE
    UBYTE DefCfg[USER_CFG_DATA_LENGTH];

    UBYTE data_lenth_master_to_muf;
    UBYTE data_lenth_muf_to_master;

	DP_ERROR_CODE bError;

    
	/*-----------------------------------------------------------------------*/
   	/* Initialisierung des EMC /External Memory Controllers                  */
   	/*-----------------------------------------------------------------------*/
	SetEMCInit();

   /*-----------------------------------------------------------------------*/
   /* init user data                                                        */
   /*-----------------------------------------------------------------------*/
   memset( &sUser, 0, sizeof(sUser) );

   /*-----------------------------------------------------------------------*/
   /* initialize VPC3                                                       */
   /*-----------------------------------------------------------------------*/
   pVpc3Channel1   = (VPC3_STRUC_PTR)VPC3_ASIC_ADDRESS;
   Vpc3AsicAddress = (VPC3_ADR)VPC3_ASIC_ADDRESS;
   pVpc3           = pVpc3Channel1;
   pDpSystem       = &sDpSystemChannel1;

   /*-----------------------------------------------------------------------*/
   /* initialize global system structure                                    */
   /*-----------------------------------------------------------------------*/
   memset( (void *)pDpSystem, 0, sizeof( VPC3_SYSTEM_STRUC ));

   /* TRUE  deactivates diagnosis handling ! */
   /* FALSE activates   diagnosis handling ! */
   pDpSystem->bUserDiagActive   = FALSE;
   pDpSystem->wOldDiag          = 0x00;
   pDpSystem->bApplicationReady = FALSE;
   pDpSystem->bState            = USER_STATE_CLEAR;

   //V.1.20
   //Abhänig vom Modus (1 oder 2) in dem sich der Messumformer befindet 
   //eine unterschiedliche Konfiguration für die Menge der über PROFIBUS
   //übertragenen Daten setzten.
   //Achtung: data_lenth_muf_to_master Darf nicht größer als DIN_BUFSIZE sein        
   //          und data_lenth_master_to_muf nicht als DOUT_BUFSIZE
   if (muf_system.modus == MODUS2)
   {
        data_lenth_muf_to_master = sizeof(struct DATENFRAME_MODUS2_STRUCT);       
   }
   else if (muf_system.modus == MODUS2_OHNE_DEBUGDATEN)
   {
        data_lenth_muf_to_master = sizeof(struct DATENFRAME_MODUS2_STRUCT)
                                    -sizeof(struct ALPHA_BETA_STRUCT);
   }
   else // Modus 1
   {
        data_lenth_muf_to_master = sizeof(struct DATENFRAME_STRUCT);       
   }
   data_lenth_master_to_muf = sizeof(struct PARAMETER_MODUS2_STRUCT);


   //Konfiguration erzeugen
   //DefCfg[0] = 0xC0;    //0xC0 == it follows 1 length byte for outputs and 1 length byte for inputs (aus der Sicht des Masters)
   //DefCfg[1] = CONSISTENCY_OVER_WHOLE_LENGTH | (data_lenth_master_to_muf-1); //Vom Master zum MUF
   //DefCfg[2] = CONSISTENCY_OVER_WHOLE_LENGTH | (data_lenth_muf_to_master-1);  //Vom MUF zum Master
   //V.1.20 ENDE

   //V.3.0.1 - Erweiterte Konfiguration da data_lenth_master_to_muf ab dieser Verion größer als 64 Byte (es stehen jeweils 6 Bits zur Verfügung)
   //          data_lenth_master_to_muf wird jetzt auf zwei Angaben aufgeteilt (auf DefCfg[1] und DefCfg[4])
   if(data_lenth_master_to_muf - 1 > 0x3F)  // data_lenth_master_to_muf > 64
   {
        DefCfg[0] = 0xC0;       //0xC0 == it follows 1 length byte for outputs and 1 length byte for inputs (aus der Sicht des Masters)
        // Vom Master zum MUF - 1. Hälfte:
        DefCfg[1] = CONSISTENCY_OVER_WHOLE_LENGTH | ( (data_lenth_master_to_muf/2 - 1)                            & 0x3F );
        // Vom MUF zum Master:
        DefCfg[2] = CONSISTENCY_OVER_WHOLE_LENGTH | ( (data_lenth_muf_to_master/2 - 1)                              & 0x3F );  
        DefCfg[3] = 0xC0;       //0xC0 == it follows 1 length byte for outputs and 1 length byte for inputs (aus der Sicht des Masters)
        // Vom Master zum MUF - 2. Hälfte:
        DefCfg[4] = CONSISTENCY_OVER_WHOLE_LENGTH | ( (data_lenth_master_to_muf - data_lenth_master_to_muf/2 - 1) & 0x3F ); 
        //                                                2.Hälfte = gesammt - 1.Hälfte
        DefCfg[5] = CONSISTENCY_OVER_WHOLE_LENGTH | ( (data_lenth_muf_to_master - data_lenth_muf_to_master/2 - 1) & 0x3F ); 
   }
   else
   {
        DefCfg[0] = 0xC0;       //0xC0 == it follows 1 length byte for outputs and 1 length byte for inputs (aus der Sicht des Masters)
        // Vom Master zum MUF:
        DefCfg[1] = CONSISTENCY_OVER_WHOLE_LENGTH | ( (data_lenth_master_to_muf - 1) & 0x3F );
        // Vom MUF zum Master:
        DefCfg[2] = CONSISTENCY_OVER_WHOLE_LENGTH | ( (data_lenth_muf_to_master - 1) & 0x3F );  
        // Keine weiteren Angaben notwendig
        DefCfg[3] = 0;
        DefCfg[4] = 0;
        DefCfg[5] = 0;
   }

   

   sUser.sCfgData.bLength = USER_CFG_DATA_LENGTH; // length of configuration data
   memcpy( &sUser.sCfgData.abData[0], &DefCfg[0], sUser.sCfgData.bLength );
   
   bError = VPC3_MemoryTest();

   //TBD doku
   if( bError != DP_OK )
   { 
	  sVpc3Error.bErrorCode = bError;
      FatalError( _DP_USER, __LINE__, &sVpc3Error );
	  return;
   }
      
    bError = VPC3_Initialization( DP_ADDR, IDENT_NR, (psCFG)&sUser.sCfgData );                  // address of slave

   if( bError != DP_OK )
   {
	  sVpc3Error.bErrorCode = bError;
      FatalError( _DP_USER, __LINE__, &sVpc3Error );
      return;
   }
   
   VPC3_Start();
	  
}//void InitProfibus( void )

/*---------------------------------------------------------------------------*/
/* function: ProfibusMain                                                    */
/*---------------------------------------------------------------------------*/
/*!
  \brief The application program has to call this function cyclically so that the PROFIBUS DP slave services can be processed.
*/
void ProfibusMain( void )
{
   VPC3_UNSIGNED8_PTR pToOutputBuffer;    // pointer to output buffer
   UBYTE              bOutputState;       // state of output data
   TVpc3Byte DP_state = 0;
   
   u16_t abtastzeit_in_us;

   float abtastzeit_in_sec; // CAggou - v3.4 - 30.08.2013

   u8_t akt_profibus_slave_address; // NTG-3000-Drives v1.1
   
   /*-------------------------------------------------------------------*/
   /* trigger watchdogs                                                 */
   /*-------------------------------------------------------------------*/
   // toggle user watchdog
   VPC3_RESET_USER_WD();   // toggle user watchdog

   /*-------------------------------------------------------------------*/
   /* internal state machine                                            */
   /*-------------------------------------------------------------------*/
   if( pDpSystem->bState == USER_STATE_CLEAR )
   {
   	  // clear data
   	  memset( &sUser.abOutput[0] , 0, 2 );
   	  memset( &sUser.abInput[0]  , 0, 2 );
   	
   	  pDpSystem->bState = USER_STATE_RUN;
   }//if( pDpSystem->bState == USER_STATE_CLEAR )

   
   /*-------------------------------------------------------------------*/
   /* VPC3+ DP-state                                                    */
   /*-------------------------------------------------------------------*/
   
   DP_state = VPC3_GET_DP_STATE();
   
   switch( DP_state )
   {
      case WAIT_PRM:
      {
         break;
      }//case WAIT_PRM:

      case WAIT_CFG:
      {
		 break;
      }//case WAIT_CFG:

      case DATA_EX:
      {
         if(    ( pDpSystem->bApplicationReady == TRUE ) && ( pDpSystem->bState == USER_STATE_RUN  )     )
         {
            /*-------------------------------------------------------------------*/
            /* profibus input (Data Slave to Master)                             */
            /*-------------------------------------------------------------------*/
            if( pDpSystem->wEvent & VPC3_EV_NEW_INPUT_DATA )
            {
				//keine Lösung: EMCSTATICCNFG0_bit.B = 1; //Buffer enabled, damit die Daten im Hintergrund zum PROFIBUS-Chip übertragen werden
               VPC3_InputDataUpdate( &sUser.abInput[0] ); //Benötigt ca 15us wenn der Buffer nicht aktiv ist
			    //keine Lösung: EMCSTATICCNFG0_bit.B = 0; //Buffer disable, da sonnst probleme bei den anderen Funktionen
               pDpSystem->wEvent &= ~VPC3_EV_NEW_INPUT_DATA;
            }//if( pDpSystem->wEvent & VPC3_EV_NEW_INPUT_DATA )
         }//if(    ( pDpSystem->bApplicationReady == TRUE ) ...
         break;
      }//case DATA_EX:

      case DP_ERROR:
      default:
      {
         sVpc3Error.bErrorCode = VPC3_GET_DP_STATE();
         FatalError( _DP_USER, __LINE__, &sVpc3Error );
         break;
      }//case DP_ERROR:
   }//switch( VPC3_GET_DP_STATE() )
   
   //PROFIBUS-Fehler-Flag ggf. zurück nehmen - Ver. 1.12 24.01.2012
#ifndef PROFIBUSFEHLER_NICHT_ZURUECKNEHMEN   
   if (DP_state != DP_ERROR)
	   muf_system.fehler.PROFIBUS_fehler = FALSE;
#endif
   
    /*-------------------------------------------------------------------*/
    /* profibus output (Data Master to Slave)                            */
    /*-------------------------------------------------------------------*/
    //Datenempfang via PROFIBUS nur im Modus 2
    //if(muf_system.modus == MODUS2 || muf_system.modus == MODUS2_OHNE_DEBUGDATEN)
    //{
       if( pDpSystem->wEvent & VPC3_EV_DX_OUT )
       {
            pDpSystem->wEvent &= ~VPC3_EV_DX_OUT;       // clear event
            pToOutputBuffer = VPC3_GetDoutBufPtr( &bOutputState );
            if( pToOutputBuffer != NULL_PTR )
            {
                // Daten aus dem Empfangspuffer in den Eingangsbereich kopieren
                CopyFromVpc3_( &sUser.abOutput[0], (void const *)pToOutputBuffer, (UWORD)pDpSystem->bOutputDataLength ); //PC

                //Anhand des 1. Bytes überprüfen ob neue Parameter übernommen werden sollen
                if(sUser.abOutput[0] == KOMMANDO_NEUE_PARAMETER)
                {
                    //Wenn sich die neuen Parameter von den vorhandenen unterscheiden
                    if( memcmp( &muf_system.parameter_modus2, &sUser.abOutput[0], sizeof(struct PARAMETER_MODUS2_STRUCT)) != 0)
                    {

                        //neue Daten in das Parameter-Struct kopieren
                        memcpy( &muf_system.parameter_modus2, &sUser.abOutput[0], sizeof(struct PARAMETER_MODUS2_STRUCT));

                        //Setzen der Abtastzeit mit der die Funktionen des Mathematik-Modusl aufgerufen werden
                        abtastzeit_in_us = GET_ABTASTZEIT(muf_system.parameter_modus2.faktor_abtastzeit);
                        SetTimePerTick(abtastzeit_in_us);
						
                        // Berechnung der Abtastzeit in Sekunden CAggou - v3.4 - 30.08.2013
                        abtastzeit_in_sec = (abtastzeit_in_us / 1000000.0f); 

                        //Berechnung von fcomp mit neuem ta und f0 initialisieren
                        /*
                        InitFcompBerechnung(
                            (0.0005 * (muf_system.parameter_modus2.faktor_abtastzeit + 1)), // Abtastzeit berechnen, 500us * Faktor
                            muf_system.parameter_modus2.f0
                        ); //v.3.3 21.02.2013 */
                        InitFcompBerechnung(abtastzeit_in_sec, muf_system.parameter_modus2.f0); //v.3.4 30.08.2013
    
                        // Initialisierung der Grenzen des Rate-of-Change-Filters CAggou - v3.4 - 30.08.2013
                        InitRateOfChangeFilter(abtastzeit_in_sec, muf_system.parameter_modus2.faktor_h);

                        //Daten im EEPROM speichern
                        SetParameterModus2Speichern();
                    }
                }//if(&sUser.abOutput[0] == KOMMANDO_NEUE_PARAMETER)
            }//if( pToOutputBuffer != NULL_PTR )
        }//if( pDpSystem->wEvent & VPC3_EV_DX_OUT )
    //}//if(muf_system.modus == MODUS2 || muf_system.modus == MODUS2_OHNE_DEBUGDATEN)

   /*-------------------------------------------------------------------*/
   /* handle here profibus interrupt events                             */
   /*-------------------------------------------------------------------*/
   if( pDpSystem->wEvent & VPC3_EV_NEW_CFG_DATA )
   {
      ApplicationReady();
   }//if( pDpSystem->wEvent & VPC3_EV_NEW_CFG_DATA )
   
}//void ProfibusMain( void )

/*---------------------------------------------------------------------------*/
/* function: FatalError                                                     */
/*---------------------------------------------------------------------------*/
void FatalError( DP_ERROR_FILE bFile, UWORD wLine, VPC3_ERRCB_PTR sVpc3Error )
{
	//PROFIBUS-Fehler-Flag Setzten	
	muf_system.fehler.PROFIBUS_fehler = TRUE; 
	
	//Ver. 1.12 - 24.01.2012
	//PROFIBUS-Chip reseten und neu initialisieren
	InitProfibus(); 
	
}//void FatalError( DP_ERROR_FILE bFile, UWORD wLine, VPC3_ERRCB_PTR sVpc3Error )

/*---------------------------------------------------------------------------*/
/* function: UserChkDpv1StatusBytes                                          */
/*---------------------------------------------------------------------------*/
DP_ERROR_CODE UserChkDpv1StatusBytes( UBYTE bDpv1Status1, UBYTE bDpv1Status2, UBYTE bDpv1Status3 )
{
DP_ERROR_CODE bRetValue;
   
   bRetValue = DP_OK;
   
   if( pDpSystem->eDPV1 == DPV1_MODE )
   {
      // DPV1 enabled
      bRetValue = DP_PRM_DPV1_NOT_SUPP;
   }//if( pDpSystem->eDPV1 == DPV1_MODE )
   else
   {
      //DPV0-Mode
      if(    (( bDpv1Status1 & 0xF8 ) != 0x00 )
          || (( bDpv1Status2 & 0xFF ) != 0x00 )
          || (( bDpv1Status3 & 0xFF ) != 0x00 )
        )
      {
         bRetValue = DP_PRM_DPV1_STATUS;
      }//if(    (( bDpv1Status1 & 0x18 ) != 0x00 ) ...
   }//else of if( pDpSystem->eDPV1 == DPV1_MODE )
   
   return bRetValue;
}//DP_ERROR_CODE UserChkDpv1StatusBytes( UBYTE bDpv1Status1, UBYTE bDpv1Status2, UBYTE bDpv1Status3 )

/*---------------------------------------------------------------------------*/
/* function: UserChkNewPrmData                                               */
/*---------------------------------------------------------------------------*/
/*!
   \brief Checking parameter data.
   The user has to program the function for checking the received parameter data.

   \param pbPrmData - address of parameter data
   \param bPrmLength - length of parameter data

   \retval DP_OK - The transferred parameterization is OK.
   \retval DP_NOK - The transferred parameterization isn't OK.
*/
DP_ERROR_CODE UserChkNewPrmData( MEM_UNSIGNED8_PTR pbPrmData, UBYTE bPrmLength )
{
MEM_STRUC_PRM_PTR psToPrmData;
DP_ERROR_CODE     bRetValue;

   pDpSystem->eDPV1 = DPV0_MODE;

   bRetValue = DP_OK;

   //if( bPrmLength == PRM_LEN_DPV1 ) //PC
   if( bPrmLength == PRM_LEN_NORM ) //PC
   {
      psToPrmData = ( MEM_STRUC_PRM_PTR )pbPrmData;

      //DPV1 Statusbyte 1
      pDpSystem->eDPV1 = ( psToPrmData->bDpv1Status1 & DPV1_STATUS_1_DPV1_ENABLE )? DPV1_MODE : DPV0_MODE;

      bRetValue = UserChkDpv1StatusBytes( psToPrmData->bDpv1Status1, psToPrmData->bDpv1Status2, psToPrmData->bDpv1Status3 );
   }//if( bPrmLength == PRM_LEN_DPV1 )
   else
   {
      bRetValue = DP_PRM_LEN_ERROR;
   }//else of if( bPrmLength == PRM_LEN_DPV1 )

   return bRetValue;
}//DP_ERROR_CODE UserChkNewPrmData( MEM_UNSIGNED8_PTR pbPrmData, UBYTE bPrmLength )

/*---------------------------------------------------------------------------*/
/* function: UserChkNewCfgData                                               */
/*---------------------------------------------------------------------------*/
/*!
   \brief Checking configuration data.
   The function VPC3_Isr() or VPC3_Poll() calls this function if the VPC3+
   has received a Check_Cfg message and has made the data available in the Cfg buffer.

   The user has to program the function for checking the received configuration data.

   \param[in] pbCfgData - address of check configuration data
   \param[in] bCfgLength - length of configuration data

   \retval VPC3_CFG_OK - The transferred configuration is OK.
   \retval VPC3_CFG_FAULT - The transferred configuration isn't OK.
   \retval VPC3_CFG_UPDATE - The transferred configuration is OK, but it's different
                             from read configuration buffer. The user will exchange
                             verified configuration with read configuration buffer.
*/
UBYTE UserChkNewCfgData( MEM_UNSIGNED8_PTR pbCfgData, UBYTE bCfgLength )
{
	UBYTE bRetValue;
	UBYTE i;


   bRetValue = VPC3_CFG_OK;

   if( bCfgLength == sUser.sCfgData.bLength )
   {
      for( i = 0; i < bCfgLength; i++ )
      {
         if( sUser.sCfgData.abData[ i ] != *pbCfgData )
         {
            bRetValue = VPC3_CFG_FAULT;
         }//if( sUser.sCfgData.abData[ i ] != *pbCfgData )

         pbCfgData++;
      }//for( i = 0; i < bCfgLength; i++ )
   }//if( bCfgLength != bRealCfgLength )
   else
   {
      bRetValue = VPC3_CFG_FAULT;
   }//else of if( bCfgLength != bRealCfgLength )

   if( ( bRetValue == VPC3_CFG_OK ) || ( bRetValue == VPC3_CFG_UPDATE ) )
   {
      UserAlarm( USER_TYPE_CFG_OK, FALSE );
      pDpSystem->wEvent |= VPC3_EV_NEW_CFG_DATA;
   }//if( ( bRetValue == VPC3_CFG_OK ) || ( bRetValue == VPC3_CFG_UPDATE ) )

   return bRetValue;
}//UBYTE UserChkNewCfgData( MEM_UNSIGNED8_PTR pbCfgData, UBYTE bCfgLength )

/*---------------------------------------------------------------------------*/
/* function: UserIsrGoLeaveDataExchange                                      */
/*---------------------------------------------------------------------------*/
/*!
   \brief The function VPC3_Isr() or VPC3_Poll() calls this function if the
   DP-Statemachine has entered the DataEx-mode or has exited it.
   With the function VPC3_GET_DP_STATE() you can find out the state of VPC3+.
*/
void UserIsrGoLeaveDataExchange( void )
{
   if( VPC3_GET_DP_STATE() != DATA_EX )
   {
      pDpSystem->bState = USER_STATE_CLEAR;
      pDpSystem->bApplicationReady = FALSE;
   }//if( VPC3_GET_DP_STATE() != DATA_EX )
}//void UserIsrGoLeaveDataExchange( void )

/*---------------------------------------------------------------------------*/
/* function: UserIsrDxOut                                                    */
/*---------------------------------------------------------------------------*/
/*!
   \brief The function VPC3_Isr() or VPC3_Poll() calls this function if the VPC3+
   has received a DataExchange message and has made the new output data
   available in the N-buffer. In the case of Power_On or Leave_Master, the
   VPC3+ clears the content of the buffer, and generates this event also.
*/
void UserIsrDxOut( void )
{
    static BOOLEAN erster_aufruf = TRUE;

    //Nicht beim ersten Aufruf der Funktion
    if (erster_aufruf == FALSE)
        pDpSystem->wEvent |= VPC3_EV_DX_OUT;

    erster_aufruf = FALSE;
}//void UserIsrDxOut( void )

/*---------------------------------------------------------------------------*/
/* function: UserIsrDiagBufferChanged                                        */
/*---------------------------------------------------------------------------*/
/*!
   \brief The function VPC3_Isr() or VPC3_Poll() calls this function if the VPC3+ has
   exchanged the diagnostic buffers, and made the old buffer available again to the user.
*/
void UserIsrDiagBufferChanged( void )
{
   // diagnosis buffer has been changed
   pDpSystem->bUserDiagActive = FALSE;
   // Fetch new diagnosis buffer
   pDpSystem->pDiagBuffer = VPC3_GetDiagBufPtr();
}//void UserIsrDiagBufferChanged( void )

/*---------------------------------------------------------------------------*/
/* function: UserIsrNewWdDpTimeout                                           */
/*---------------------------------------------------------------------------*/
/*!
   \brief The function VPC3_Isr() or VPC3_Poll() calls this function if the
   watchdog timer expired in the WD mode DP_Control.
   The communication between master and slave is time controlled, every time you're
   disconnecting the PROFIBUS master or you're disconnecting the PROFIBUS cable you'll
   get this event.
*/
void UserIsrNewWdDpTimeout( void )
{
    //not used in our application
}//void UserIsrNewWdDpTimeout( void )

/*---------------------------------------------------------------------------*/
/* function: UserIsrClockSynchronisation                                     */
/*---------------------------------------------------------------------------*/
#if DP_TIMESTAMP
   void UserIsrClockSynchronisation( void )
   {
      //not used in our application
   }//void UserIsrClockSynchronisation( void )
#endif//#if DP_TIMESTAMP

/*---------------------------------------------------------------------------*/
/* function: UserIsrBaudrateDetect                                           */
/*---------------------------------------------------------------------------*/
/*!
   \brief The function VPC3_Isr() or VPC3_Poll() calls this function if the VPC3+
   has exited the Baud_Search mode and has found a baudrate.
   With the macro VPC3_GET_BAUDRATE() you can detect the baudrate.
*/
void UserIsrBaudrateDetect( void )
{
   //not used in our application
}//void UserIsrBaudrateDetect( void )

/*---------------------------------------------------------------------------*/
/* function: UserIsrNewGlobalControlCommand                                  */
/*---------------------------------------------------------------------------*/
/*!
   \brief The function VPC3_Isr() or VPC3_Poll() calls this function if the VPC3+
   has received a Global_Control message. The GC_Command_Byte can be read out
   with the macro VPC3_GET_GC_COMMAND().
*/
void UserIsrNewGlobalControlCommand( void )
{
   //not used in our application
}//void UserIsrNewGlobalControlCommand( void )

/*---------------------------------------------------------------------------*/
/* function: UserIsrNewSetSlaveAddress                                       */
/*---------------------------------------------------------------------------*/
/*!
   \brief The function VPC3_Isr() or VPC3_Poll() calls this function if the VPC3+
   has received a Set_Slave_Address message and made the data available in the SSA
   buffer.
*/
void UserIsrNewSetSlaveAddress( void )
{
    //not used in our application
/*
MEM_STRUC_SSA_BLOCK_PTR psSsa;

   //copy ssa-data from VPC3+S to local structure
   CopyFromVpc3_( (MEM_UNSIGNED8_PTR)&pDpSystem->abPrmCfgSsaHelpBuffer[0], VPC3_GET_SSA_BUF_PTR(), 4 );
   psSsa = (MEM_STRUC_SSA_BLOCK_PTR)&pDpSystem->abPrmCfgSsaHelpBuffer[0];

   //store the new address and the bit bNoAddressChanged for the next startup
   print_string("\r\nNewAddr: ");
   print_hexbyte(psSsa->bTsAddr);
   print_hexbyte(psSsa->bNoAddressChanged);
   print_hexbyte(psSsa->bIdentHigh);
   print_hexbyte(psSsa->bIdentLow);
*/
}//void UserIsrNewSetSlaveAddress( void )

/*******************************************************************************
* SetParameterModus2Speichern
*
* Funktion um die Parameter für Modus 2 im EEPROM zu speichern
*******************************************************************************/
void SetParameterModus2Speichern()
{
	//u8_t size;
	u8_t anzahl_bytes;
	u8_t *ptr;
	u8_t address;
	
    //Buffer mit Informationen über einen aufgetretenen Fehler
    u8_t fehler_info[8];

    BOOLEAN ret_val;
//char ptr_temp[30]={0x01,0x02,0x03,0x04,0x05,0x06,0x07,0x08,0x09,0x0a,0x0b,0x0c,0x0d,0x0e,0x0f,0x10,0x11,0x12,0x13,0x14,0x15,0x16,0x17,0x18,0x19,0x1a,0x1b,0x1c,0x1d,0x1e};


	//Daten in das EEPROM schreiben	
    muf_system.fehler.EEPROM_fehler = FALSE;
	address         = PARAMETER_MODUS2_START_ADDRESS; // 'Achtung: adress muss mod 8 = 0 sein !
	ptr             = (u8_t *)&muf_system.parameter_modus2;
    anzahl_bytes    = sizeof(struct PARAMETER_MODUS2_STRUCT);


    //memcpy(ptr,ptr_temp,30);
	//Wichtig es dürfen nicht mehr als PAGE_WRITE_BUFFER_SIZE Bytes gleichzeitig geschrieben werden
	while(anzahl_bytes > PAGE_WRITE_BUFFER_SIZE) // 8
	{
		ret_val = SetEEPROMWrite(address, ptr, PAGE_WRITE_BUFFER_SIZE);
	
		if (ret_val != TRUE )
        {
            muf_system.fehler.EEPROM_fehler = TRUE;
            break;
        }
		
         
		Delay(20); // Wichtig: 20 ms Pause

        address 		+= PAGE_WRITE_BUFFER_SIZE;
		ptr				+= PAGE_WRITE_BUFFER_SIZE;

        anzahl_bytes 	-= PAGE_WRITE_BUFFER_SIZE;
	}

    if (muf_system.fehler.EEPROM_fehler == FALSE)
    {
        ret_val = SetEEPROMWrite(address, ptr, anzahl_bytes);
        if (ret_val != TRUE )
            muf_system.fehler.EEPROM_fehler = TRUE;
        Delay(20); // Wichtig: 20 ms Pause
    }

#ifdef DEBUG_EEPROM_FEHLER_UEBER_ETHERNET_SENDEN
    if (muf_system.fehler.EEPROM_fehler == TRUE)
    {
        //Zu Debug-Zwecken die Fehlerinformationen semmeln

        //Daten deutlich kennzeichnen
        fehler_info[0] = 0x55;
        fehler_info[1] = 0xAA;
        fehler_info[2] = 0x55;
        fehler_info[3] = 0xAA;
        //Und Infos über den fehler anfügen
        fehler_info[4] = ret_val; //enthält den Code des Fehlers
        fehler_info[5] = address;
        fehler_info[6] = *ptr;
        fehler_info[7] = anzahl_bytes;
        //... und via. Ethernet senden
        tapdev_send(fehler_info, sizeof(fehler_info));
    }
#endif
}
/*******************************************************************************
* ENDE SetParameterModus2Speichern
*******************************************************************************/

