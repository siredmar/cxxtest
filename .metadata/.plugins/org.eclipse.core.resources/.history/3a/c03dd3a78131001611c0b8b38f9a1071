//***************************************************************************
//
// Module      : Utilities.c                ==>     DCon2010 - M E A S U R E
//
// Author      : Reiner Beh
// Date        : 04.07.11
// Last update : 07.12.12
// This update : 12.12.12
//
// Description : Initialisierungen
//
// Remarks     :
//
// Functions   :                                                               > Zeitdauer
//
// - LED_ToggleTest()                                               07.12.12
// - LED_Switch()                                                   23.10.12
// - LED_Signal()                                                   23.10.12
// - LED_Toggle()                                                   07.12.12
// - LED_ToggleAndStop()                                            07.12.12
// - LED_ToggleAndWait()                                            07.12.12
//
// - CalcChecksum()                                                 09.08.11
//
// - CheckFalseCnt()                                                12.12.12
// - SetDataZero()                                                  12.12.12
// - SelectSamples()                                                12.12.12
// - SelectSamples_CLV()                                            12.12.12
// - Convert_PHX()                                                  02.09.12
//
// - Convert_ADCdata_PHU_StartSample()                              23.07.12   > ~   3 µs
// - Convert_ADCdata_PHU_Samples_FP()                               13.06.12   > ~     µs
// - Convert_ADCsamples_HP()                                        11.07.12   > ~  35 µs
// - Convert_PH_PHU()                                               16.08.12   > ~ 150 µs
// - Convert_PH_PHV()                                               11.07.12
// - Convert_PH_PHW()                                               11.07.12
//
// - ConvertToDecimal()                                             05.02.10
//
// - CheckSwReset()                                                 25.09.12
//
//***************************************************************************

//---------------------------------------------------------------------------
// Include
//---------------------------------------------------------------------------

#include <Math.h>
#include <stdio.h>
#include <errno.h>

#include "Definitions.h"
#include "Externals.h"

#include "Utilities.h"


//>==========================================================================
// G O B A L S
//>==========================================================================
struct st_Samples stSamples[4];
struct st_ADC stADC;
struct st_ActValue stActValue;

unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;


//===========================================================================
//
// Function    : LED_ToggleTest
//
// Date        : 07.12.12
// Last update : 07.12.12
// This update : 07.12.12
//
// Description : 
//
// Input       : -
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_ToggleTest(void)
{
    unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;
    unsigned long ulWaitTimeOuter, ulWaitTimeInner;
    unsigned int uiLEDstate;

#ifdef TEST_LED_TXD_MESS_ACTIVE
    // ================================================================
    // Ausgang TXD_MESS für TEST-LED initialisieren
    // ================================================================
    TRISBbits.TRISB12 = 0;        // Output RB12: TEST-LED an TXD_MESS => Pin 20
#endif  // TEST_LED_TXD_MESS_ACTIVE


    ulWaitTimeOuter = 10;
    ulWaitTimeInner = 100000;
    uiLEDstate = LED_TXD_MESS_OFF;

    while(1)
    {

        if (uiLEDstate == (unsigned int) LED_TXD_MESS_ON)
        {
            OUT_TXD_MESS = LED_TXD_MESS_OFF; // LED "OFF"
            uiLEDstate = LED_TXD_MESS_OFF;
        }
        else
        {
            OUT_TXD_MESS = LED_TXD_MESS_ON;  // LED "ON"
            uiLEDstate = LED_TXD_MESS_ON;
        }

        // Wait ...
        for (ulWaitTimeOuter_Tmp = 0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++)
        {
            for (ulWaitTimeInner_Tmp = 0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++)
            {
            }
        }

    }

}

//===========================================================================
//
// Function    : LED_Switch
//
// Date        : 11.10.11
// Last update : 22.02.12
// This update : 23.10.12
//
// Description : LED ON (1) / OFF (0)
//
// Input       : -
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_Switch(unsigned int uiState)
{
    if (uiState != 1)
    {
        OUT_TXD_MESS = LED_TXD_MESS_OFF; // LED "OFF"
    }
    else
    {
        OUT_TXD_MESS = LED_TXD_MESS_ON;  // LED "ON"
    }
}

//===========================================================================
//
// Function    : LED_Signal
//
// Date        : 05.10.12
// Last update : 23.10.12
// This update : 06.12.12
//
// Description : LED signalisieren
//               > in dieser Funktion bleiben ... STOP ...
//
// Input       : unsigned long ulWaitTimeOuter
//               unsigned long ulWaitTimeInner
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_Signal(unsigned long ulWaitTimeOuter, unsigned long ulWaitTimeInner, unsigned int uiBlinkCnt)
{
    unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;
    unsigned int i;


    //#ifdef TEST_LED_TXD_MESS_ACTIVE
    // ================================================================
    // Ausgang TXD_MESS für TEST-LED initialisieren
    // ================================================================
    //  TRISBbits.TRISB12 = 0;        // Output RB12: TEST-LED an TXD_MESS => Pin 20
    //#endif  // TEST_LED_TXD_MESS_ACTIVE


    stSystem.uiLEDerrState = uiBlinkCnt;

    while (1)
    {

        for (i=0; i<uiBlinkCnt; i++)
        {

            LED_Switch(1);  // LED "ON"
            // Wait SHORT ...
            for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++)
            {
                for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++)
                {
                }
            }
            LED_Switch(0);  // LED "OFF"
            // Wait SHORT ...
            for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++)
            {
                for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++)
                {
                }
            }

        }  // for (i=0; i<uiBlinkCnt; i++)

        // Wait LONG ...
        for (i=0; i<5; i++)
        {
            // Wait SHORT ...
            for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++)
            {
                for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++)
                {
                }
            }
        }  // for (i=0; i<5; i++)

    }  // while (1)

}

//===========================================================================
//
// Function    : LED_Toggle
//
// Date        : 11.10.11
// Last update : 22.02.11
// This update : 07.12.12
//
// Description : LED toggeln 
//
// Input       : -
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_Toggle(void)
{

    if (stSystem.uiLEDdspState == (unsigned int) LED_TXD_MESS_ON)
    {
        OUT_TXD_MESS = LED_TXD_MESS_OFF; // LED "OFF"
        stSystem.uiLEDdspState = LED_TXD_MESS_OFF;
    }
    else
    {
        OUT_TXD_MESS = LED_TXD_MESS_ON; // LED "ON"
        stSystem.uiLEDdspState = LED_TXD_MESS_ON;
    }

}

//===========================================================================
//
// Function    : LED_ToggleAndStop
//
// Date        : 11.10.11
// Last update : 06.12.12
// This update : 07.12.12
//
// Description : LED toggeln 
//               > in dieser Funktion bleiben ... STOP ...
//
// Input       : unsigned long ulWaitTimeOuter
//               unsigned long ulWaitTimeInner
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_ToggleAndStop(unsigned long ulWaitTimeOuter, unsigned long ulWaitTimeInner)
{

    unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;


    //#ifdef TEST_LED_TXD_MESS_ACTIVE
    // ================================================================
    // Ausgang TXD_MESS für TEST-LED initialisieren
    // ================================================================
    //    TRISBbits.TRISB12 = 0; // Output RB12: TEST-LED an TXD_MESS => Pin 20
    //#endif  // TEST_LED_TXD_MESS_ACTIVE


    LED_Toggle();

    while (1)
    {
        LED_Toggle();
        // Wait ...
        for(ulWaitTimeOuter_Tmp=0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++)
        {
            for(ulWaitTimeInner_Tmp=0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++)
            {
            }
        }
    }

}

//===========================================================================
//
// Function    : LED_ToggleAndWait
//
// Date        : 11.10.11
// Last update : 06.12.12
// This update : 07.12.12
//
// Description : LED toggeln 
//               > mit Warteschleife ...
//
// Input       : unsigned long ulWaitTimeOuter
//               unsigned long ulWaitTimeInner
//
// Output      :
//
// Return      :
//
//===========================================================================
void LED_ToggleAndWait(unsigned long ulWaitTimeOuter, unsigned long ulWaitTimeInner)
{

    //unsigned long ulWaitTimeOuter_Tmp, ulWaitTimeInner_Tmp;

    //#ifdef TEST_LED_TXD_MESS_ACTIVE
    // ================================================================
    // Ausgang TXD_MESS für TEST-LED initialisieren
    // ================================================================
    //    TRISBbits.TRISB12 = 0; // Output RB12: TEST-LED an TXD_MESS => Pin 20
    //#endif  // TEST_LED_TXD_MESS_ACTIVE


    LED_Toggle();

    // Wait ...
    for (ulWaitTimeOuter_Tmp = 0; ulWaitTimeOuter_Tmp < ulWaitTimeOuter; ulWaitTimeOuter_Tmp++)
    {
        for (ulWaitTimeInner_Tmp = 0; ulWaitTimeInner_Tmp < ulWaitTimeInner; ulWaitTimeInner_Tmp++)
        {
        }
    }

}

// ===================================================
//
// Function    : CalcChecksum
//
// Date        : 09.08.11
// Last update : 09.08.11
// This update : 09.08.11
//
// Description : Checksumme berechnen
//
// Aufbau des I2C-Master/Slave-Protokolls :
// 1. Byte / Index 2 : Länge  : 0x...
// 2. Byte / Index 2 : CMD... : 0x...
// 3. Byte / Index 3 : DATA-1 : 0x...
// 4. Byte / Index 4 : DATA-2 : 0x...
// m. Byte / Index n : DATA-m : 0x...
// n. Byte / Index n+1 : CHKSUM : 0x...  => XOR Byteweise ohne CHKSUM selbst
//
// Input       :
//
// Output      :
//
// Return      :
//
// ===================================================
unsigned char CalcChecksum(char* cpData, unsigned int uiDataLen)
{
    unsigned int i;
    unsigned char ucChecksum = 0;
    char* cpDataTemp;

    // Checksumme berechnen ...
    cpDataTemp = cpData;
    ucChecksum = 0;
    for (i = 0; i < uiDataLen; i++)
    {
        ucChecksum ^= *cpDataTemp; // XOR byteweise
        cpDataTemp++;
    }
    return (ucChecksum);
}

#ifdef ADC_PER_DMA
//===========================================================================
//
// Function    : InitSamples
//
// Date        : 05.12.12
// Last update : 05.12.12
// This update : 05.12.12
//
// Description : ADC-Werte initialisieren,
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void InitSamples(unsigned int uiChannelNr)
{
    switch (uiChannelNr)
    {
    case ADC_CHANNEL_NR_PHU: // AN4 : AV_VOLT_PHASE_U
        Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_PHU, ADC_IDX_OFFSET_PHU);
        break;
    case ADC_CHANNEL_NR_PHV: // AN5 : AV_VOLT_PHASE_V
        Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_PHV, ADC_IDX_OFFSET_PHV);
        break;
    case ADC_CHANNEL_NR_PHW: // AN9 : AV_VOLT_PHASE_W
        Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_PHW, ADC_IDX_OFFSET_PHW);
        break;
    case ADC_CHANNEL_NR_CLV: // AN10 : AV_CURR_LOAD_V
        Init_ADC_SCANDATA_ChIndex(ADC_CHANNEL_IDX_CLV, ADC_IDX_OFFSET_CLV);
        break;
    }

    MeasState[uiChannelNr] = MEAS_STATE_RESET;
}

//===========================================================================
//
// Function    : CheckFalseCnt
//
// Date        : 12.12.12
// Last update : 12.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               FehlerCounter checken ...
//               > Spannung Phase U/V/W
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void CheckFalseCnt(unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
    if (stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] >= PHASE_X_FALSE_CNT_MAX)
    {
        stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
        // PHASE_X = 0 V
        stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
        stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
        if (uiChannelNr == ADC_CHANNEL_NR_PHU)
        {
            stActValue.uiTestData_03++;
        }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

    }
}

//===========================================================================
//
// Function    : SetDataZero
//
// Date        : 12.12.12
// Last update : 12.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               Daten zurücksetzen ...
//               > Spannung Phase U/V/W
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void SetDataZero(unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
    // PHASE_X = 0 V
    stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;

#ifdef TEST_TX_TESTDATA_SIG_ZERO_01
    if (uiChannelNr == ADC_CHANNEL_NR_PHU)
    {
        stActValue.uiTestData_03++;
    }
#endif  // TEST_TX_TESTDATA_SIG_ZERO_01

}


#define HSP_DBG
#ifdef HSP_DBG
#define HSP_DBG_OUTPUT (stActValue.iPhaseVal_PH_UVW_Mean)
int HSP_DBG_MAX = 0;
int HSP_DBG_MAX_RESET[4] = {1};
int HSP_DBG_OLD_PHASE_VALUES[4] = {1};
int HSP_DBG_CURRENT_PHASE_VALUES[4] = {0};
int HSP_DBG_OLD_MEAN_VALUE = 0;
#define MEAS_FACTOR (0.1464f)

int HalfPeriodCounter[4] = {0};
int HalfPeriodSum[4] = {0};

int MeasurementValuesSquare[1000];

typedef enum
{
    MEAS_STATE_RESET = 0,
    MEAS_STATE_RESET_UNDER_ZERO,
    MEAS_STATE_RESET_OVER_ZERO,
    MEAS_STATE_UNDER_ZERO,
    MEAS_STATE_OVER_ZERO
} MeasStateType;

MeasStateType MeasState[4];


void SelectSamples(struct st_Samples* pstSamples, unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
    unsigned int *puiTmp_Read;
    unsigned int *puiTmp_End;
    unsigned int Data;
    int Quad = 0;
    float SquareRoot = 0.0f;
    unsigned int CurrentValue;

    puiTmp_Read = pstSamples->puiSample_Start;
    puiTmp_End = pstSamples->puiSample_End;

    CurrentValue = *puiTmp_Read;

    // max. gesamtes SampleArray durchsuchen ...
    for (Data = 0; Data < SAMP_BUFF_SIZE; Data++)
    {
        switch(MeasState[uiChannelIdx])
        {
        case MEAS_STATE_RESET:
            if(CurrentValue > ADC_MAXVALUE_HALF)
            {
                MeasState[uiChannelIdx] = MEAS_STATE_RESET_OVER_ZERO;
            }
            else
            {
                MeasState[uiChannelIdx] = MEAS_STATE_RESET_UNDER_ZERO;
            }
            break;

        case MEAS_STATE_RESET_OVER_ZERO:
            if(CurrentValue > ADC_MAXVALUE_HALF)
            {
                MeasState[uiChannelIdx] = MEAS_STATE_RESET_OVER_ZERO;
            }
            else
            {
                MeasState[uiChannelIdx] = MEAS_STATE_RESET_UNDER_ZERO;
            }
            break;

        case MEAS_STATE_RESET_UNDER_ZERO:
            if(CurrentValue > ADC_MAXVALUE_HALF)
            {
                MeasState[uiChannelIdx] = MEAS_STATE_RESET_OVER_ZERO;
            }
            else
            {
                MeasState[uiChannelIdx] = MEAS_STATE_RESET_UNDER_ZERO;
            }
            break;

        case MEAS_STATE_OVER_ZERO:
            if(CurrentValue > ADC_MAXVALUE_HALF)
            {
                HalfPeriodSum[uiChannelIdx] += CurrentValue;
                HalfPeriodCounter++;
            }
            else // CurrentValue <= ADC_MAXVALUE_HALF
            {
                Quad = HalfPeriodSum[uiChannelIdx] * HalfPeriodSum[uiChannelIdx];
                SquareRoot = (float)sqrt((float)Quad);
                stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)((float)((float)SquareRoot / (float)HalfPeriodCounter));

                HalfPeriodCounter = 0;
                HalfPeriodSum[uiChannelIdx] = 0;
                MeasState[uiChannelIdx] = MEAS_STATE_UNDER_ZERO;
            }
            break;

        case MEAS_STATE_UNDER_ZERO:
            if(CurrentValue < ADC_MAXVALUE_HALF)
            {

            }
            else // CurrentValue >= ADC_MAXVALUE_HALF
            {

                MeasState[uiChannelIdx] = MEAS_STATE_OVER_ZERO;
            }
            break;

        default:
            break;
        }


        puiTmp_Read++;  // zeigt jetzt auf PHV
        puiTmp_Read++;  // zeigt jetzt auf PHW
        puiTmp_Read++;  // zeigt jetzt auf CLV
        puiTmp_Read++;  // zeigt jetzt auf nächste PHU

        // Check auf Ende des DMA-Speichers : max 4*96 Samples ...
        if (puiTmp_Read > puiTmp_End)
        {
            pstSamples->puiAct_End = puiTmp_End;
            break;
        }
    }
    stActValue.iPhaseVal_PH_UVW_Mean = (HSP_DBG_OLD_PHASE_VALUES[0] + HSP_DBG_OLD_PHASE_VALUES[1] + HSP_DBG_OLD_PHASE_VALUES[2]) / 3;
}
#else

//===========================================================================
//
// Function    : SelectSamples
//
// Date        : 05.12.12
// Last update : 07.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               suchen und markieren der Halb-Perioden ...
//               > Spannung Phase U/V/W
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
long lX, lQ;
double fCalcVal, fSqrt;

void SelectSamples(struct st_Samples* pstSamples, unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
    unsigned int *puiTmp_Read;
    unsigned int *puiTmp_End;
    unsigned int i, j;
    unsigned int uiState;

    if (pstSamples->uiSampleCnts >= 833)
    {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
        // Signal ist kleiner ~30 Hz
        InitSamples(uiChannelNr);
        stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
        stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
        return;
    }

    puiTmp_Read = pstSamples->puiSample_Start;
    puiTmp_End = pstSamples->puiSample_End;

    uiState = ERR_NONE;
    j = SAMP_BUFF_SIZE; // 96 Samples
    // max. gesamtes SampleArray durchsuchen ...
    for (i = 0; i < j; i++)
    {
        switch (stADC.uiState[uiChannelIdx])
        {
        //######################################################################
        case SIGNAL_RESET:
            //######################################################################
            // Übergang von negativ zu positiv wird gesucht
            if (*puiTmp_Read > ADC_MAXVALUE_HALF)
            {         // > 2048 => Null-Linie
                stADC.uiState[uiChannelIdx] = SIGNAL_RESET_OVER_NULL;
            }
            else
            {
                stADC.uiState[uiChannelIdx] = SIGNAL_RESET_UNDER_NULL;
            }
            stADC.uiStartIdx[uiChannelIdx] = 0;
            stADC.uiStopIdx[uiChannelIdx] = 0;
            pstSamples->uiSampleCnts = 0;
            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
            break;

            //######################################################################
        case SIGNAL_RESET_UNDER_NULL:
            //######################################################################
            // Nulldurchgang von negativ zu positiv suchen ...
            if (*puiTmp_Read >= ADC_MAXVALUE_HALF)
            {
                pstSamples->puiAct_Start = puiTmp_Read;
                pstSamples->uiSampleCnts++;   // 1. Sample OVER_NULL

                // 1. Wert
                if (*pstSamples->puiAct_Start >= ADC_MAXVALUE_HALF)
                {
                    stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start - ADC_MAXVALUE_HALF;
                }
                else
                {
                    stADC.uiDeltaVal[uiChannelIdx] = ADC_MAXVALUE_HALF - *pstSamples->puiAct_Start;
                }
                stADC.lAddVal[uiChannelIdx] = 0;

                stADC.uiState[uiChannelIdx] = SIGNAL_OVER_NULL;
            }
            else
            {
                if (pstSamples->uiSampleCnts >= 833)
                {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                    // Signal ist kleiner ~30 Hz
#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
                    if (uiChannelNr == ADC_CHANNEL_NR_PHU)
                    {
                        stActValue.uiTestData_01++;
                    }
#endif
                    InitSamples(uiChannelNr);
                    stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                    break;
                }
            }
            break;

            //######################################################################
        case SIGNAL_RESET_OVER_NULL:
            //######################################################################
            // Nulldurchgang von positiv zu negativ suchen ...
            if (*puiTmp_Read <= ADC_MAXVALUE_HALF)
            {
                pstSamples->puiAct_Start = puiTmp_Read;
                pstSamples->uiSampleCnts++;   // 1. Sample UNDER_NULL

                // 1. Wert
                if (*pstSamples->puiAct_Start >= ADC_MAXVALUE_HALF)
                {
                    stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start - ADC_MAXVALUE_HALF;
                }
                else
                {
                    stADC.uiDeltaVal[uiChannelIdx] = ADC_MAXVALUE_HALF - *pstSamples->puiAct_Start;
                }
                stADC.lAddVal[uiChannelIdx] = 0;

                stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_NULL;
            }
            else
            {
                if (pstSamples->uiSampleCnts >= 833)
                {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                    // Signal ist kleiner ~30 Hz

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
                    if (uiChannelNr == ADC_CHANNEL_NR_PHU)
                    {
                        stActValue.uiTestData_01++;
                    }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

                    InitSamples(uiChannelNr);
                    stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                    break;
                }
            }
            break;

            //######################################################################
        case SIGNAL_OVER_NULL:
            //######################################################################
            if (pstSamples->uiSampleCnts >= 833)
            {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                // Signal ist kleiner ~30 Hz

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
                if (uiChannelNr == ADC_CHANNEL_NR_PHU)
                {
                    stActValue.uiTestData_02++;
                }
#endif

                InitSamples(uiChannelNr);
                stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                break;
            }
            // Nulldurchgang von positiv zu negativ suchen ...
            if (*puiTmp_Read < ADC_MAXVALUE_HALF)
            {

                // positive Halb-Periode gefunden ...

#ifdef TEST_TX_TESTDATA_SIG_FOUND
                if (uiChannelNr == ADC_CHANNEL_NR_PHU)
                {
                    stActValue.uiTestData_02++;
                }
#endif  // TEST_TX_TESTDATA_SIG_FOUND


                pstSamples->puiAct_End = puiTmp_Read;
                stADC.uiState[uiChannelIdx] = SIGNAL_OVER_END;

                lX = (long) stADC.uiDeltaVal[uiChannelIdx] * (-1);
                lQ = lX * lX; // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...

                if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN)
                {  // 10
                    CheckFalseCnt(uiChannelIdx, uiChannelNr);
                    break;
                }

                fCalcVal = (double) pstSamples->uiSampleCnts;


                //    fSqrt = (sqrt((double)lAdd / fCalcVal)) * stSystem.fK_Factor_UVW;
                // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
                fSqrt = sqrt((double) stADC.lAddVal[uiChannelIdx] / fCalcVal);

                if (fSqrt < (double)PHASE_X_VALUE_CHECK)
                {  // 25.0 V : 3.0 = 8.33 V  ==> *10 wegen 1 Kommastelle und ohne Verstärkungsfaktor 3,0 !
                    SetDataZero(uiChannelIdx, uiChannelNr);

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
                    if (uiChannelNr == ADC_CHANNEL_NR_PHU)
                    {
                        stActValue.uiTestData_01++;
                    }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_01

                    break;

                }
                else
                {
                    // 1 halbe Periode ...           // Anzahl der Sampels ==> Frequenz ...
                    if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN)
                    {
                        // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...

                        // FehlerCounter checken ...
                        CheckFalseCnt(uiChannelIdx, uiChannelNr);
                        break;
                    }

                    stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

                    //=====================================================
                    // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
                    //=====================================================
                    if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)
                    {
                        // erste Initialisierung
                        stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
                    }
                    else
                    {

                        lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
                        stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )

                    } // if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)

                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
                    stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;

                } // if (fSqrt < (double)PHASE_X_VALUE_CHECK)


                uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
                InitSamples(uiChannelNr);

            }
            else
            {
                // nächster gültiger Sample der Halbwelle ...
                pstSamples->uiSampleCnts++; // x. Sample OVER_NULL
                //=====================================================
                // quadratische Mittelwertbildung einer Halb-Periode ...
                //=====================================================
                // alle bisher gesampelten Werte addieren ...
                lX = (long) *puiTmp_Read - (long) ADC_MAXVALUE_HALF;
                lQ = lX * lX;    // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...
            }
            break;

            //######################################################################
        case SIGNAL_UNDER_NULL:
            //######################################################################
            if (pstSamples->uiSampleCnts >= 833)
            {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                // Signal ist kleiner ~30 Hz

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
                if (uiChannelNr == ADC_CHANNEL_NR_PHU)
                {
                    stActValue.uiTestData_02++;
                }
#endif  // TEST_TX_TESTDATA_SIG_TRUE_02

                InitSamples(uiChannelNr);
                stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                break;
            }
            // Nulldurchgang von negativ zu positiv suchen ...
            if (*puiTmp_Read > ADC_MAXVALUE_HALF)
            {
                pstSamples->puiAct_End = puiTmp_Read; // - 1;
                stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_END;


                lX = (long) stADC.uiDeltaVal[uiChannelIdx];
                lQ = lX * lX; // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...



                if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN)
                {  // 10
                    // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
                    // Samples darf nit "0" sein, da ansonsten Division durch "0" im Folgenden ...
                    //            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
                    // PHASE_X = 0 V
                    // FehlerCounter checken ...
                    CheckFalseCnt(uiChannelIdx, uiChannelNr);
                    break;
                }

                fCalcVal = (double) pstSamples->uiSampleCnts;

                // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
                fSqrt = sqrt((double) stADC.lAddVal[uiChannelIdx] / fCalcVal);

                if (fSqrt < (double)PHASE_X_VALUE_CHECK)
                {  // 25.0 V : 3.0 = 8.33 V  ==> *10 wegen 1 Kommastelle und ohne Verstärkungsfaktor 3,0 !
                    SetDataZero(uiChannelIdx, uiChannelNr);

#ifdef TEST_TX_TESTDATA_SIG_TRUE_02
                    if (uiChannelNr == ADC_CHANNEL_NR_PHU)
                    {
                        stActValue.uiTestData_02++;
                    }
#endif
                    break;
                }
                else
                {  // if (fSqrt < (double)PHASE_X_VALUE_CHECK)// 1 halbe Periode  // Anzahl der Sampels ==> Frequenz ...

                    if ( pstSamples->uiSampleCnts <= PHASE_X_SAMPLES_CNT_MIN)
                    {
                        CheckFalseCnt(uiChannelIdx, uiChannelNr);
                        break;
                    }
                    stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

                    //=====================================================
                    // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
                    //=====================================================
                    if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)
                    {
                        // erste Initialisierung
                        stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
                    }
                    else
                    {

                        lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
                        stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )

                    } // if ((stADC..uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)

                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
                    stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;

                }


                uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
                InitSamples(uiChannelNr);

            }
            else
            {
                pstSamples->uiSampleCnts++; // x. Sample UNDER_NULL

                //=====================================================
                // quadratische Mittelwertbildung einer Halb-Periode ...
                //=====================================================
                // alle bisher gesampelten Werte addieren ...
                lX = (long) *puiTmp_Read - (long) ADC_MAXVALUE_HALF;
                lQ = lX * lX;    // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...

            }
            break;

            //######################################################################
        default:
            //######################################################################
            // Error ...
            uiState = ERR_MEASURE_ADC_004; // falscher Stati bei der Suche nach einer Halbwelle ...
            InitSamples(uiChannelNr);
            break;

        } // switch (stADC.uiVOLT_PHU_State[stADC.uiVOLT_PHU_SelectIdx])


        if (pstSamples->uiSampleCnts >= 833)
        {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
            // Signal ist kleiner ~30 Hz
            InitSamples(uiChannelNr);
            stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
            break;
        }

        if (uiState != ERR_NONE)
        {
            // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
            break;
        }
        else
        {

            // Mehr Samples als erlaubt ...
            // 40 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 40 Hz-Signal : max. 625 Samples ...
            // somit : bei 96 Samples pro DMA-Interrupt, werden max. 7 DMA-Interrupts benötigt um eine ganze
            // Periode zu sampeln. Für eine halbe Periode werden somit 4 DMA-Interrupts benötigt !
            // 30 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 30 Hz-Signal : max. 833 Samples ...
            // somit : bei 96 Samples pro DMA-Interrupt, werden max. 9 DMA-Interrupts benötigt um eine ganze
            // Periode zu sampeln. Für eine halbe Periode werden somit 5 DMA-Interrupts benötigt !
            // => somit sind 19,2 ms notwendig, um eine HalbPeriode für 4 Kanäle mit je 96 Samples pro DMA_Interrupt
            //    und 10 µs Wandlungszeit pro Sample
            //    ( (4*96) * 5 DMA-Interrupts ) * 10 µs ==> 19,2 ms
            if (pstSamples->uiSampleCnts >= 833)
            {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                //        stActValue.iVolt_PHASE_U_Eff = 111;
                //        stActValue.fFreq_PHASE_U = 11.1;
                //        stADC.uiVOLT_PHU_State[uiArrayIdx] = SIGNAL_RESET;
                //        pstSamples->puiProcess_WR_Act = pstSamples->puiProcess_WR_Start;
                //        pstSamples->uiProcess_WR_State = 0;
                InitSamples(uiChannelNr);
                stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                break;
            }

            // WEITER : nächste Leseadresse ... (WEITER For ...)
            puiTmp_Read++;  // zeigt jetzt auf PHV
            puiTmp_Read++;  // zeigt jetzt auf PHW
            puiTmp_Read++;  // zeigt jetzt auf CLV
            puiTmp_Read++;  // zeigt jetzt auf nächste PHU

            // Check auf Ende des DMA-Speichers : max 4*96 Samples ...
            if (puiTmp_Read > puiTmp_End)
            {
                // Suche beenden, da bisher beschriebenes DMA-Array-Ende erreicht ...
                // StartAdresse für nächsten Zyklus eintragen ...
                pstSamples->puiAct_End = puiTmp_End;
                uiState = ERR_MEASURE_ADC_005; // aktuell eingelesenes Array-Ende erreicht, bei der Suche nach einer Halbwelle ...
                // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
                break;
            }

        } // if (uiState != ERR_NONE)

    } // for (i=0; i<j; i++)
}
#endif

//===========================================================================
//
// Function    : SelectSamples_CLV
//
// Date        : 06.12.12
// Last update : 07.12.12
// This update : 12.12.12
//
// Description : ADC-Werte auswerten,
//               suchen und markieren der Halb-Perioden ...
//               > NUR STROM CURR_LOAD_V
//
//               Zeitdauer : ... µs
//
// Input       : -
//
// Output      : -
//
// Return      : -
//
//===========================================================================
void SelectSamples_CLV(struct st_Samples* pstSamples, unsigned int uiChannelIdx, unsigned int uiChannelNr)
{
    unsigned int *puiTmp_Read;
    unsigned int *puiTmp_End;
    unsigned int i, j;
    unsigned int uiState;

    long lX, lQ;
    double fCalcVal, fSqrt;


    puiTmp_Read = pstSamples->puiSample_Start;
    puiTmp_End = pstSamples->puiSample_End;

    uiState = ERR_NONE;

    j = SAMP_BUFF_SIZE; // 96 Samples

    // max. gesamtes SampleArray durchsuchen ...
    for (i = 0; i < j; i++)
    {
        switch (stADC.uiState[uiChannelIdx])
        {
        case SIGNAL_RESET:
            // Übergang von negativ zu positiv wird gesucht
            if (*puiTmp_Read > ADC_MAXVALUE_HALF)
            {         // > 2048 => Null-Linie
                stADC.uiState[uiChannelIdx] = SIGNAL_RESET_OVER_NULL;
            }
            else
            {
                stADC.uiState[uiChannelIdx] = SIGNAL_RESET_UNDER_NULL;
            }
            stADC.uiStartIdx[uiChannelIdx] = 0;
            stADC.uiStopIdx[uiChannelIdx] = 0;
            pstSamples->uiSampleCnts = 0;
            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
            break;

        case SIGNAL_RESET_UNDER_NULL:
            // Nulldurchgang von negativ zu positiv suchen ...
            if (*puiTmp_Read >= ADC_MAXVALUE_HALF)
            {
                pstSamples->puiAct_Start = puiTmp_Read;
                pstSamples->uiSampleCnts++;   // 1. Sample OVER_NULL

                // 1. Wert
                if (*pstSamples->puiAct_Start >= ADC_MAXVALUE_HALF)
                {
                    stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start - ADC_MAXVALUE_HALF;
                }
                else
                {
                    stADC.uiDeltaVal[uiChannelIdx] = ADC_MAXVALUE_HALF - *pstSamples->puiAct_Start;
                }
                stADC.lAddVal[uiChannelIdx] = 0;

                stADC.uiState[uiChannelIdx] = SIGNAL_OVER_NULL;
            }
            else
            {
                if (pstSamples->uiSampleCnts >= 833)
                {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                    // Signal ist kleiner ~30 Hz
                    InitSamples(uiChannelNr);
                    stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                    break;
                }
            }
            break;

        case SIGNAL_RESET_OVER_NULL:
            // Nulldurchgang von positiv zu negativ suchen ...
            if (*puiTmp_Read <= ADC_MAXVALUE_HALF)
            {
                pstSamples->puiAct_Start = puiTmp_Read;
                pstSamples->uiSampleCnts++;   // 1. Sample UNDER_NULL

                // 1. Wert
                if (*pstSamples->puiAct_Start >= ADC_MAXVALUE_HALF)
                {
                    stADC.uiDeltaVal[uiChannelIdx] = *pstSamples->puiAct_Start - ADC_MAXVALUE_HALF;
                }
                else
                {
                    stADC.uiDeltaVal[uiChannelIdx] = ADC_MAXVALUE_HALF - *pstSamples->puiAct_Start;
                }
                stADC.lAddVal[uiChannelIdx] = 0;

                stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_NULL;
            }
            else
            {
                if (pstSamples->uiSampleCnts >= 833)
                {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                    // Signal ist kleiner ~30 Hz
                    InitSamples(uiChannelNr);
                    stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                    break;
                }
            }
            break;

        case SIGNAL_OVER_NULL:
            if (pstSamples->uiSampleCnts >= 833)
            {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                // Signal ist kleiner ~30 Hz
                InitSamples(uiChannelNr);
                stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                break;
            }
            // Nulldurchgang von positiv zu negativ suchen ...
            if (*puiTmp_Read < ADC_MAXVALUE_HALF)
            {
                pstSamples->puiAct_End = puiTmp_Read;
                stADC.uiState[uiChannelIdx] = SIGNAL_OVER_END;
                // Halb-Periode gefunden ...

                lX = (long) stADC.uiDeltaVal[uiChannelIdx] * (-1);
                lQ = lX * lX; // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...

                if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN)
                {
                    CheckFalseCnt(uiChannelIdx, uiChannelNr);
                    break;
                }
                fCalcVal = (double) pstSamples->uiSampleCnts;
                // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
                fSqrt = sqrt((double) stADC.lAddVal[uiChannelIdx] / fCalcVal);

                if (fSqrt < (double)CURR_LOAD_V_VALUE_CHECK)
                {  // 2.0 A ???
                    SetDataZero(uiChannelIdx, uiChannelNr);
                    break;
                }
                else
                {  // if (fSqrt < (double)CURR_LOAD_V_VALUE_CHECK)  1 halbe Periode ... Anzahl der Sampels ==> Frequenz ...
                    if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN)
                    {
                        CheckFalseCnt(uiChannelIdx, uiChannelNr);
                        break;
                    }

                    stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

                    //=====================================================
                    // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
                    //=====================================================
                    if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)
                    {
                        // erste Initialisierung
                        stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
                    }
                    else
                    {
                        lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
                        stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )
                    }
                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
                    stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
                }

                uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
                InitSamples(uiChannelNr);

            }
            else
            {
                // nächster gültiger Sample der Halbwelle ...
                pstSamples->uiSampleCnts++; // x. Sample OVER_NULL

                //=====================================================
                // quadratische Mittelwertbildung einer Halb-Periode ...
                //=====================================================
                // alle bisher gesampelten Werte addieren ...
                lX = (long) *puiTmp_Read - (long) ADC_MAXVALUE_HALF;
                lQ = lX * lX;    // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...

            }
            break;

        case SIGNAL_UNDER_NULL:
            if (pstSamples->uiSampleCnts >= 833)
            {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                // Signal ist kleiner ~30 Hz
                InitSamples(uiChannelNr);
                stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                break;
            }
            // Nulldurchgang von negativ zu positiv suchen ...
            if (*puiTmp_Read > ADC_MAXVALUE_HALF)
            {
                pstSamples->puiAct_End = puiTmp_Read; // - 1;
                stADC.uiState[uiChannelIdx] = SIGNAL_UNDER_END;
                // Halb-Periode gefunden ...

                lX = (long) stADC.uiDeltaVal[uiChannelIdx];
                lQ = lX * lX; // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ; // Summe aller Quadrate ...



                if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN)
                {
                    // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
                    // Samples darf nit "0" sein, da ansonsten Division durch "0" im Folgenden ...
                    //            stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;
                    // PHASE_X = 0 V
                    // FehlerCounter checken ...
                    CheckFalseCnt(uiChannelIdx, uiChannelNr);
                    break;
                }

                fCalcVal = (double) pstSamples->uiSampleCnts;

#ifdef ADC_BIT_10
                //          fSqrt = (sqrt((double)stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.52;     // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
                fSqrt = (sqrt((double) stADC.lAddVal[uiChannelIdx] / fCalcVal)) * 11.16; // Vref = 3.000 V => (2.92826 / 1.012) * 4 wegen 10 Bit - Normierung ...
#endif  // ADC_BIT_10

#ifdef ADC_BIT_12

                //    fSqrt = (sqrt((double)lAdd / fCalcVal)) * stSystem.fK_Factor_UVW;
                // Multiplikation mit K-Faktor wird in SLAVE durchgeführt ...
                fSqrt = sqrt((double) stADC.lAddVal[uiChannelIdx] / fCalcVal);

#endif  // ADC_BIT_12



                if (fSqrt < (double)CURR_LOAD_V_VALUE_CHECK)
                {  // 2.0 A ???

                    // FehlerCounter checken ...
                    //            CheckFalseCnt(uiChannelIdx, uiChannelNr);
                    // Signale "0" ..
                    SetDataZero(uiChannelIdx, uiChannelNr);
                    break;


                    // Spg. < 10 V
                    //Restart_ADC_SCANDATA(72);  // Anzeige : 72 * Wurzel 3 = 125

                    // Interrupt-Input für Frequenz-Messung sperren,
                    // ein Jittern am Int-Input könnte ansonsten das System lahm legen ...
                    //      IEC1bits.INT1IE = 0;    // Disable INT1 Interrupt Service Routine

                }
                else
                {  // if (fSqrt < (double)CURR_LOAD_V_VALUE_CHECK)

                    // 1 halbe Periode

                    // Anzahl der Sampels ==> Frequenz ...

                    if ( pstSamples->uiSampleCnts <= CURR_LOAD_V_SAMPLES_CNT_MIN)
                    {
                        // Frequenz zu gross, oder Spg. dümpelt der Wert irgendwo bei "0" ...
                        // FehlerCounter checken ...
                        CheckFalseCnt(uiChannelIdx, uiChannelNr);
                        break;
                    }

                    stActValue.fPhaseFreq[uiChannelIdx] = 1.0 / (fCalcVal * T3_TA_HP); // * 2 wegen Halb-Periode (200 µs)

                    //=====================================================
                    // gleitende Mittelwertbildung zur Glättung mit 2, 4, 8 Werten ...
                    //=====================================================
                    if ((stADC.uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)
                    {
                        // erste Initialisierung
                        stADC.uiPhaseInitState[uiChannelIdx] |= 0x0001;
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseLastValue[uiChannelIdx] = stADC.ulPhaseMeanActSqrt[uiChannelIdx]; // Vergangenheitswert : 0,5 * x[n-1]
                    }
                    else
                    {

                        lX = (unsigned long) (fSqrt * 5.0); // 0,5 * x[n]  (*10 wegen Kommastelle)
                        stADC.ulPhaseMeanActSqrt[uiChannelIdx] = stADC.ulPhaseLastValue[uiChannelIdx] + lX; // (0,5 * x[n-1] ) + (0,5 * x[n])
                        stADC.ulPhaseLastValue[uiChannelIdx] = lX; // (0,5 * x[n-1] )

                    } // if ((stADC..uiPhaseInitState[uiChannelIdx] & 0x0001) != 0x0001)

                    stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)(stADC.ulPhaseMeanActSqrt[uiChannelIdx] / 10ul);
                    stActValue.uiPhaseVal_FalseCnt[uiChannelIdx] = 0;

                } // if (fSqrt < (double)CURR_LOAD_V_VALUE_CHECK)


                uiState = ERR_MEASURE_ADC_003; // falsche Kanalnummer bei der Suche nach einer Halbwelle ...
                InitSamples(uiChannelNr);

            }
            else
            {
                pstSamples->uiSampleCnts++; // x. Sample UNDER_NULL

                //=====================================================
                // quadratische Mittelwertbildung einer Halb-Periode ...
                //=====================================================
                // alle bisher gesampelten Werte addieren ...
                lX = (long) *puiTmp_Read - (long) ADC_MAXVALUE_HALF;
                lQ = lX * lX;    // X hoch 2
                stADC.lAddVal[uiChannelIdx] += lQ;      // Summe aller Quadrate ...

            }
            break;

        default:
            // Error ...
            uiState = ERR_MEASURE_ADC_004; // falscher Stati bei der Suche nach einer Halbwelle ...
            InitSamples(uiChannelNr);
            break;

        } // switch (stADC.uiVOLT_PHU_State[stADC.uiVOLT_PHU_SelectIdx])


        if (pstSamples->uiSampleCnts >= 833)
        {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
            // Signal ist kleiner ~30 Hz
            InitSamples(uiChannelNr);
            stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
            stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
            break;
        }

        if (uiState != ERR_NONE)
        {
            // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
            break;
        }
        else
        {

            // Mehr Samples als erlaubt ...
            // 40 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 40 Hz-Signal : max. 625 Samples ...
            // somit : bei 96 Samples pro DMA-Interrupt, werden max. 7 DMA-Interrupts benötigt um eine ganze
            // Periode zu sampeln. Für eine halbe Periode werden somit 4 DMA-Interrupts benötigt !
            // 30 Hz : TA = 10 µs bei 4 Kanälen => 40 µs pro Sample eines Kanales und 30 Hz-Signal : max. 833 Samples ...
            // somit : bei 96 Samples pro DMA-Interrupt, werden max. 9 DMA-Interrupts benötigt um eine ganze
            // Periode zu sampeln. Für eine halbe Periode werden somit 5 DMA-Interrupts benötigt !
            // => somit sind 19,2 ms notwendig, um eine HalbPeriode für 4 Kanäle mit je 96 Samples pro DMA_Interrupt
            //    und 10 µs Wandlungszeit pro Sample
            //    ( (4*96) * 5 DMA-Interrupts ) * 10 µs ==> 19,2 ms
            if (pstSamples->uiSampleCnts >= 833)
            {  // < 30 Hz-Signal => 833 * 40 µs = 33,3 ms
                //        stActValue.iVolt_PHASE_U_Eff = 111;
                //        stActValue.fFreq_PHASE_U = 11.1;
                //        stADC.uiVOLT_PHU_State[uiArrayIdx] = SIGNAL_RESET;
                //        pstSamples->puiProcess_WR_Act = pstSamples->puiProcess_WR_Start;
                //        pstSamples->uiProcess_WR_State = 0;
                InitSamples(uiChannelNr);
                stActValue.fPhaseFreq[uiChannelIdx] = 0.0;
                stActValue.iPhaseVal_Eff[uiChannelIdx] = (int)0;
                break;
            }

            // WEITER : nächste Leseadresse ... (WEITER For ...)
            puiTmp_Read++;  // zeigt jetzt auf PHV
            puiTmp_Read++;  // zeigt jetzt auf PHW
            puiTmp_Read++;  // zeigt jetzt auf CLV
            puiTmp_Read++;  // zeigt jetzt auf nächste PHU

            // Check auf Ende des DMA-Speichers : max 4*96 Samples ...
            if (puiTmp_Read > puiTmp_End)
            {
                // Suche beenden, da bisher beschriebenes DMA-Array-Ende erreicht ...
                // StartAdresse für nächsten Zyklus eintragen ...
                pstSamples->puiAct_End = puiTmp_End;
                uiState = ERR_MEASURE_ADC_005; // aktuell eingelesenes Array-Ende erreicht, bei der Suche nach einer Halbwelle ...
                // ENDE : Daten wurden ausgewertet ... (ENDE for ...)
                break;
            }

        } // if (uiState != ERR_NONE)

    } // for (i=0; i<j; i++)

}
#endif  // ADC_PER_DMA


//===========================================================================
//
// Function    : ConvertToDecimal
//
// Date        : 07.02.09
// Last update : 07.02.09
// This update : 12.05.09
//
// Description : A positive long integer is convertet into up to 10 decimal
//               digits. The result is returned in an array of given length.
//               The function accepts only positve values and no overflow
//               is detected, therefore the user has to care for this.
//
// Input       : - ULONG ulValue : positive binary value
//               - UCHAR aData[] : array to contain the decimal result
//               - UCHAR ucLength: maximum length of the decimal value
//
// Output      : - UCHAR aData[] : array of converted data
//
// Return      : -
//
//===========================================================================
void ConvertToDecimal(unsigned long ulValue, unsigned char aData[], unsigned char ucLength)
{
    unsigned char aBuffer[10], ucIdx;

    // initialize buffer
    ucIdx = sizeof (aBuffer);
    while (ucIdx--)
        aBuffer[ucIdx] = 0;

    // 10^9
    while (ulValue >= 1000000000)
    {
        ulValue -= 1000000000;
        aBuffer[9] += 1;
    }
    // 10^8
    while (ulValue >= 1000000)
    {
        ulValue -= 100000000;
        aBuffer[8] += 1;
    }
    // 10^7
    while (ulValue >= 10000000)
    {
        ulValue -= 10000000;
        aBuffer[7] += 1;
    }
    // 10^6
    while (ulValue >= 1000000)
    {
        ulValue -= 1000000;
        aBuffer[6] += 1;
    }
    // 10^5
    while (ulValue >= 100000)
    {
        ulValue -= 100000;
        aBuffer[5] += 1;
    }
    // 10^4
    while (ulValue >= 10000)
    {
        ulValue -= 10000;
        aBuffer[4] += 1;
    }
    // 10^3
    while (ulValue >= 1000)
    {
        ulValue -= 1000;
        aBuffer[3] += 1;
    }
    // 10^2
    while (ulValue >= 100)
    {
        ulValue -= 100;
        aBuffer[2] += 1;
    }
    // 10^1
    while (ulValue >= 10)
    {
        ulValue -= 10;
        aBuffer[1] += 1;
    }
    // 10^0
    aBuffer[0] = ulValue;

    while (ucLength--)
        aData[ucLength] = aBuffer[ucLength];
}

//===========================================================================
//
// Function    : CheckSwReset
//
// Date        : 25.09.12
// Last update : 25.09.12
// This update : 25.09.12
//
// Description : Software-RESET durchführen
//               ausgelöst per SLAVE-2
//
// Input       :
//
// Output      :
//
// Return      :
//
//===========================================================================
void CheckSwReset(void)
{

#ifdef DIRECT_MEASURE_SLAVE_IO_ACTIVE

    Read_SlaveInput_3(1);

#ifdef UART1_ACTIVE

#ifdef MANUELL_RESET

    if ( (stSystem.uiInit & INIT_M_MEASURE) == INIT_M_MEASURE)
    {

        if (stUART1.stUART.ucTxStart == 1)
        {  // wird immer 640 ms nach RESET gesetzt ...

            // Check des Signals der Kommunikation mit SLAVE ...
            if ( (stIO.ucSlaveInput & STATE_PER_CON_MESS_3_R) == STATE_PER_CON_MESS_3_R)
            {
                // SW-Reset der MEASURE-CPU
                DoSWReset();
            }

        }  // if (stUART1.stUART.ucTxStart == 1)

    }  // if ( (stSystem.uiInit & INIT_M_MEASURE) == INIT_M_MEASURE)

#endif

#endif  // UART1_ACTIVE
#endif  // DIRECT_MEASURE_SLAVE_IO_ACTIVE

}
