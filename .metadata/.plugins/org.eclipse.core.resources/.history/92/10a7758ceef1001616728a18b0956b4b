//**********************************************************************************************
// Modulname: main.c	
//**********************************************************************************************
//
// Messumformer  - MUF
//
// Bearbeiter: Philipp Compensis
// Firma:      HSS Barschat & Krönert GBR
// Tel.:       09129 28520
//
//
// Der Messumformer wird in Kraftwerken eingesetzt und ist dort Teil eines Regelkreises.
// Er erfasst alle 100 µs drei Spannungen und drei Ströme vom Generator und verendet diese mit
// dem nächten 100 µs Takt via UDP über Ethernet. ZusÃ¤tzlich werden noch alle 2ms zwei DC-Ströme
// und eine DC-Spannung erfasst und ebenfalls Ã¼bermittelt. Alternativ zu Ethernetübertragung
// können die Messwerte per PROFIBUS abgefragt werden.
// 
// Diese Main.c-Datei beinhaltet die Hauptablaufsteuerung des Controllers.
//
// Versionshistory / Änderungen siehe MUF.h
// 
//**********************************************************************************************

#define MUF_MAIN

//
//***************  INCLUDE-DATEIEN *********************************************
//
#include <string.h> //für memcmp()

#include "MUF.h"

#include "init.h"
#include "Std_Types.h"
#include "ethernet.h"
#include "dcadc.h"
//#include "fehler_LED.h" //V.3.0
#include "watchdog.h"
#include "profibus.h"
#include "kalibrierung.h"
#include "normierung.h"
#include "math.h"
#include "LEDs.h"           //V.3.0
#include "filter.h"         //v.3.3 22.02.2013
#include "FIR_Filter.h"


struct MUF_SYSTEM muf_system;
//
//**********************  Funktions-Prototypen  ********************************
//
extern 	void VPC3_Isr();

//
//****************************  Defines  ***************************************
//
#define FREQUENZ_U1           0

//
//****************************  Modul-Variablen ********************************
//
volatile struct BOOTLOADER_UPDATE_DATA bootloader_update_data __attribute__ ((section(".user_data"), aligned(4)));


/*******************************************************************************
* main
*******************************************************************************/
int main(void)
{
            BOOLEAN           main_timer_flag = FALSE;// Wird auf TRUE gesetzt wenn die Hauptschleife durchlaufen werden soll
            float             frequenz;               // Im Modus 2 aus U1 ermittelte Frequenz
            float             fcomp_temp;             // Im Modus 2 berechnete kompensieret Frequenz
            BOOLEAN           fcomp_schwelle_unterschritten;
            BOOLEAN           fcomp_bildung_gestoert;
            float             fcomp_gefiltert;        //V.2.3.1 //gefilterte Kompensierte Frequenz
            float             p_gefiltert;            //V.3.0.1 // gefiltert effektive Wirklieistu
            float             fcomp_beta_gefiltert;   // V3.4 // gefilterte kompensierte begrenzte Frequenz
    struct  ALPHA_BETA        alpha_beta_fcomp;       // Währen der fcomp-Berechung berechnete
                                                      // alpha- und beta-Komponenten
    static  u8_t              main_counter = 0;

            u16_t             i;

    #ifdef KALIBRIERUNGS_SW
          u8_t                kommando;
          wert_multimeter_t   wert_multimeter;
    #endif

	//************************  Initalisierung  ********************************
	InitMain();

    FEHLER_LED_ON();

/*
#warning debug!
    muf_system.parameter_modus2.faktor_u = 1;
    muf_system.parameter_modus2.faktor_i = 1;
    muf_system.parameter_modus2.faktor_h = 5.4;
	muf_system.parameter_modus2.xq		 = 0.0;
    muf_system.parameter_modus2.eingangs_filter_deaktiviert = FALSE;
*/

    //TBD Kommentar fehlt. 
    // Warum wird z.B. Funktionsblock 3 nicht auf FALSE oder TRUE gesetzt?
    // Warum werden die anderen auf TRUE gesetzt //PComp 05.12.2013
	muf_system.funktionsblock_1_aktiv = TRUE;
    muf_system.funktionsblock_2_aktiv = TRUE; // FCom-Berechung, FComp-Filterung, P-Filterung
    //muf_system.funktionsblock_3_aktiv = FALSE; // Rate-Of-Change, Erweiterter Phasenausfall
    muf_system.funktionsblock_4_aktiv = TRUE;

	//*************************  Kalibrierung  *********************************
	//if (DREHSCHALTER == 0xF)
	//{
	//*************************  Normaler Betrieb  *********************************
	//else
	//{    
		//******************************  Main Loop  *******************************
		// Endlos-Schleife: Abbruch durch Ausschalten des Controllers
		while (TRUE)
		{
            // Main-Timer-Aufruf abhänig vom Modus
            if(muf_system.modus == MODUS1)
            {
                // Main-Timer-Aufruf alle 100us
                if (muf_system.main_timer_flag_100us == TRUE)
                {
                    muf_system.main_timer_flag_100us = FALSE; //Reset flag
                    main_timer_flag = TRUE;
                }
            }

            if(muf_system.modus == MODUS2 | muf_system.modus == MODUS2_OHNE_DEBUGDATEN)
            {
                // Main-Timer-Aufruf alle 500us
                if (muf_system.main_timer_flag_500us == TRUE)
                {
                    muf_system.main_timer_flag_500us = FALSE; //Reset flag
                    main_timer_flag = TRUE;
                }
            }

			//******************************  Main-Timer-Aufruf  *******************
			// Aufruf abhängig vom Modus
			if (main_timer_flag == TRUE)
			{
				main_timer_flag = FALSE; //Reset flag

                // Main Counter für die einstellbare Abtastzeit/Zykluszeit
                // Mit der die Daten berechnet bzw. versendet werden
                main_counter++;
                if(main_counter == (muf_system.parameter_modus2.faktor_abtastzeit + 1))
                    main_counter = 0;			
				
				// Versenden der Daten über Ethernet: (erster Durchlauf ohne Versenden!)
                // Nur bei jedem n. Durchlauf (abhänig vom faktor_abtastzeit )
				if (main_counter == 0 )
                {
                    TESTPIN200_HIGH();
                    TESTPIN201_HIGH();

                    if(muf_system.ethernet_tx_enable == TRUE)
                        SetEthernetTx(); //(Dauer ca. 19.5us)
                }
                else
                {
                    // ca. 5us Pause für die AD-Wandlung
                    for(u8_t i = 0; i < 50; i++); 
                }

                // Setzen des Datenframes und ggf. Berechnungen nur bei jedem n. Durchlauf
                if (main_counter == 0)
                {					
                        SetDatenFrameModus1(&muf_system.normierte_werte, muf_system.fehler_byte, muf_system.info); //(Dauer ca. 2,5us) 
                    
                    // UDP-Frame erzeugen (Prüfsumme des UDP-Frames setzen) (Dauer ca. 6,5us)
                    SetUDPFrameChecksum();
                    
                    //Ethernet-Übertragung wird erst nachdem einmal der ADC abgefragt wurde durchgeführt
                    muf_system.ethernet_tx_enable = TRUE;	
                    
                    // PROFIBUS
                #ifdef MIT_PROFIBUS		
                    SetProfibusModus1(&muf_system.normierte_werte, muf_system.fehler_byte); //PROFIBUS bearbeiten
                #endif	

                // CAggou - v3.4 - Abfrage, ob ein Update durchgeführt werden soll
                CheckUpdateUDPMessage();

                }
				
                // State Machine zum Abfragen der DC-Werte auch jedes mal aufrufen (ink. Normierung)
				// (Dauer bis zu 4,5us)
				SetDCDaten(&muf_system.ADC_werte, &muf_system.normierte_werte);

				// Watchdog reseten
				SetFeedWatchdog();

                // Testpin low setzen
                TESTPIN200_LOW();
                TESTPIN201_LOW();

			} //if (MAIN_TIMER_flag == TRUE) 
			//**********************************************************************

            // ACHTUNG ohne diese kurze Verzögerung
            //        kommte es zu Fehlern im Releas
            for(i=0; i<1; i++); 

		}// ENDE while(TRUE)	
		
	//}//ENDE if (BOOT_JUMPER ==1) else
}
/*******************************************************************************
* ENDE main
*******************************************************************************/
