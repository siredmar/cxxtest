//**********************************************************************************************
// Modulname: EEPREOM	
//**********************************************************************************************
//
// Messumformer  - MUF
//
// Bearbeiter: Philipp Compensis
// Firma: HSS Barschat & Krönert GBR
// Tel.:  09129 28520
//
// 
// eeprom.c enthält die Funktionen zum Beschreiben und Auslesen des EEPROMS
// und zum Initialisieren des EEPROMS bzw der I2C-Schnisstelle
//
// 15.02.2012 GetEEPROMRead() wurde komplett überarbeitet da nach dem letzten Byte kein NoACK
//            gesendet wurde.
// 
//**********************************************************************************************


//*****************  INCLUDE-DATEIEN *******************************************
#include "MUF.h"
#include "spi.h"
#include "EEPROM.h"


//************************ Defines *********************************************
#define TIMEOUT				0xFF       //V.2.4.1

//I2C Control Set Register
#define I2CONSET_I2EN		0x00000040 //I2C interface enable
#define I2CONSET_AA			0x00000004 //Set Assert acknowledge flag
#define I2CONSET_SI			0x00000008 //Set I2C interrupt flag
#define I2CONSET_STO		0x00000010 //Set STOP flag
#define I2CONSET_STA		0x00000020 //Set START flag

//I2C Control clear Register
#define I2CONCLR_AAC		0x00000004 //Clear Assert acknowledge flag
#define I2CONCLR_SIC		0x00000008 //Clear I2C interrupt flag
#define I2CONCLR_STAC		0x00000020 //Clear START flag
#define I2CONCLR_I2ENC		0x00000040 //I2C interface disable


//***************  Funktions-Prototypen  ***************************************
BOOLEAN GetEEPROMRead(u8_t address, u8_t *buffer, u8_t buffer_length);
BOOLEAN SetEEPROMWrite(u8_t address, u8_t *buffer, u8_t buffer_length);
void SetI2CWrite(u8_t data);


/*******************************************************************************
* SetEEPROMInit
*
* Funktion zum Initialisieren der I2C-Schnittstelle und des EEPROMS
*******************************************************************************/
void SetEEPROMInit()
{	
	//Init der I2C-Schnittstelle
	
	//PCONP |= (1 << 8);
    PCONP |= PCONP_PCI2C0_MASK; //Power up I2C0
	
	//Select I2C pins and their modes
	//in Pin Function Select register
	PINSEL1 &= ~0x03C00000;
	PINSEL1 |= 0x01400000;	/* set P0[27] and P0[28] to I2C0 SDA and SCK */
							/* function to 01 on both SDA and SCK. */
	
	//Clear Assert acknowledge, 2C interrupt and Set START flag. Disable I2C
	I2C0CONCLR = I2CONCLR_AAC | I2CONCLR_SIC | I2CONCLR_STAC | I2CONCLR_I2ENC; 

	///Set Duty Cycle Registers
	I2C0SCLL   = 0x80; //I2C SCL High Duty Cycle Register
	I2C0SCLH   = 0x80; //I2C SCL Low Duty Cycle Register
		// 0x80 + 0x80 --> ca. 71 kHz
	
	//enable I2C interface 
	I2C0CONSET = I2CONSET_I2EN;
	
};
/*******************************************************************************
* ENDE SetEEPROMInit
*******************************************************************************/


/*******************************************************************************
* GetEEPROMRead
*
* Funktion zum Auslesen des EEPROMS
*******************************************************************************/
BOOLEAN GetEEPROMRead(u8_t address, u8_t *buffer, u8_t buffer_length)
{
	u8_t status = 0;
	u16_t t;
	
	if (buffer_length == 0)
		return FALSE;
								  
	if ((address + buffer_length - 1) > HIGHEST_READ_ADDRESS)
		return FALSE;
	
	//-------------------------------------------
	
	I2C0CONSET = I2CONSET_STA; //Set Start Flag
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}
	
	status = I2C0STAT; //0x08 = "A START condition has been transmitted."
	if (status != 0x08)
		return EEPROM_FEHLER;
	
	//I2C-Schreibzugriff Starten um dann im nächsten Schritt die Adresse von der
	//gelesen werden soll an's EEPROM zu senden
	I2C0DAT = (EEPROM_SLAVE_ADDRESS << 1) | WRITE_BIT; 
	
	//Clear Interrupt Flag and Start Flag
	I2C0CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC); 
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}
	
	status = I2C0STAT; 
	//0x18 = "Slave address + Write bit has been transmitted; ACK has been received."
	if (status != 0x18)
		return EEPROM_FEHLER;
	
	I2C0DAT = address; //Adresse von der gelesen werden soll ans EEPROM senden
	I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}
	
	status = I2C0STAT;
	//0x28 = "Data byte in I2DAT has been transmitted; ACK has been received."
	if (status != 0x28)
		return EEPROM_FEHLER;
	
	I2C0CONSET = I2CONSET_STA; //Set Repeated-start flag
	I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}
	
	status = I2C0STAT; //sollte 0x10 sein
	if (status != 0x10)
		return EEPROM_FEHLER;
	
	I2C0DAT = (EEPROM_SLAVE_ADDRESS << 1) | READ_BIT;
	
	I2C0CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC); //Clear Interrupt Flag and Start Flag
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}
	
	status = I2C0STAT;
	//0x40 = "Slave address + Read bit has been transmitted; ACK has been received."
	if (status != 0x40)
		return EEPROM_FEHLER;

	
    //Bei allen Bytes außer beim letzten
	while(buffer_length > 1)
	{


        I2C0CONSET = I2CONSET_AA;  //Assert ACK after data is received
        I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag
	
        //-------------------------------------------

		//Auf I2C Interrupt Flag warten
		t = TIMEOUT;
		while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
		{
			if ( t-- == 0)
				return EEPROM_FEHLER;
		}
		
		status = I2C0STAT; 
        //0x50 = "Data byte has been received; ACK has been returned."
        if (status != 0x50)
            return EEPROM_FEHLER;
		
        //Daten einlesen
		*buffer = I2C0DAT;
		
		buffer++;
		
        /*
        //Das der Empfang des letzten Bytes soll nicht mit einem ACK bestätigt 
		//werden (> 2 da die Anweisung immer für das nächste 
		//Byte was empfangen wird gilt.)
		if (buffer_length > 2)	
			I2C0CONSET = I2CONSET_AA;	// assert ACK after data is received
        */

        buffer_length--;
	}

    //für das letzte Byte

    I2C0CONCLR = I2CONSET_AA;  //No ACK after data is received
    I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag	

    //-------------------------------------------

    //Auf I2C Interrupt Flag warten
    t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}

    status = I2C0STAT; 
    //0x5 = "Data byte has been received; NoACK has been returned."
    if(status != 0x58)
        return EEPROM_FEHLER;

    //Daten einlesen
    *buffer = I2C0DAT;

    I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag	

	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}
		
	I2C0CONSET = I2CONSET_STO; // Set Stop flag 
  	I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag
            
  	//Wait for STOP detected
	t = TIMEOUT;
  	while( I2C0CONSET & I2CONSET_STO )
	{
		if ( t-- == 0)
			return EEPROM_FEHLER;
	}

	//-------------------------------------------
  
	return TRUE;
}
/*******************************************************************************
* ENDE GetEEPROMRead
*******************************************************************************/


/*******************************************************************************
* SetEEPROMWrite
*
* Funktion zum Beschreiben des EEPROMs
*******************************************************************************/
BOOLEAN SetEEPROMWrite(u8_t address, u8_t *buffer, u8_t buffer_length)
{
	u8_t status = 0;
	//u8_t t;       //Zu klein für das Timeout. Macht um Releas Probleme
    u16_t t;        //V.2.4.1
	
	if (buffer_length == 0)
		return FALSE;
								  
	if ((unsigned int )((unsigned int )address + (unsigned int )buffer_length - 1) > HIGHEST_READ_ADDRESS)
		return FALSE;
	
	//-------------------------------------------
	
	I2C0CONSET = I2CONSET_STA; //Set Start Flag
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER_11;
	}
	
	status = I2C0STAT; //0x08 = "A START condition has been transmitted."
	if (status != 0x08)
		return EEPROM_FEHLER_12;
	
	I2C0DAT = (EEPROM_SLAVE_ADDRESS << 1) | WRITE_BIT; //I2C-Schreibzugriff Starten um dann im nächsten Schritt die Adresse an die geschrieben werden soll an's EEPROM zu senden
	I2C0CONCLR = (I2CONCLR_SIC | I2CONCLR_STAC); //Clear Interrupt Flag and Start Flag
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER_13;
	}
	
	status = I2C0STAT; //0x18 = "Slave address + Write bit has been transmitted; ACK has been received."
	if (status != 0x18)
		return EEPROM_FEHLER_14;
	
	I2C0DAT = address; //Adresse an die geschrieben werden soll an das EEPROM senden
	I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag
	
	//-------------------------------------------
	
	while(buffer_length--)
	{
		//Auf I2C Interrupt Flag warten
		t = TIMEOUT;
		while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
		{
			if ( t-- == 0)
				return EEPROM_FEHLER_15;
		}
		
		status = I2C0STAT; //0x28 = "Data byte in I2DAT has been transmitted; ACK has been received."
		if (status != 0x28)
			return EEPROM_FEHLER_16;
		
		I2C0DAT = *buffer; //Daten an EEPROM schreiben
		buffer++;
		
		I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag	
	}
	
	//-------------------------------------------
	
	//Auf I2C Interrupt Flag warten
	t = TIMEOUT;
	while((I2C0CONSET & I2C0CONSET_SI_MASK) == 0)
	{
		if ( t-- == 0)
			return EEPROM_FEHLER_17;
            //Dieser Fehler tritt im Release auf!
	}
		
	I2C0CONSET = I2CONSET_STO; // Set Stop flag 
  	I2C0CONCLR = I2CONCLR_SIC; //Clear Interrupt Flag
            
  	/*--- Wait for STOP detected ---*/
	t = TIMEOUT;
  	while( I2C0CONSET & I2CONSET_STO )
	{
		if ( t-- == 0)
			return EEPROM_FEHLER_18;
	}

	//-------------------------------------------

	return TRUE;
}
/*******************************************************************************
* ENDE SetEEPROMWrite
*******************************************************************************/

/*******************************************************************************
* SetEEPromTest
*
* Funktion zum Beschreiben des EEPROMs
*******************************************************************************/
BOOLEAN SetEEPromTest()
{
    u32_t i;
    u8_t  size;
    u8_t  *ptr;
    u8_t  address;
    u8_t anzahl_bytes;
    
    u8_t write_test_daten[26];
    u8_t read_test_daten[26];
    
    BOOLEAN ret_val;
    
    size = sizeof(write_test_daten);
    
    // Initialisierung der Test-Array
    for(i = 0; i < sizeof(write_test_daten); i++)
    {
      write_test_daten[i] = i+1;
      read_test_daten[i]  = 0x0;
    }
    
    //----------------------------------------------------------------------
    //  Schreiben der Testdaten

    address      = KALIBRIERUNGSWERTE_START_ADDRESS;
    ptr          = (u8_t *)&write_test_daten;
    anzahl_bytes = sizeof(write_test_daten);
    
    // Wichtig es dürfen nicht mehr als PAGE_WRITE_BUFFER_SIZE Bytes gelichzeitig geschrieben werrden
	while(anzahl_bytes > PAGE_WRITE_BUFFER_SIZE)
	{
		ret_val = SetEEPROMWrite(address, ptr, PAGE_WRITE_BUFFER_SIZE);
		
		if (ret_val == FALSE )
			return FALSE;
		
		address 		+= PAGE_WRITE_BUFFER_SIZE;
		ptr				+= PAGE_WRITE_BUFFER_SIZE;
		anzahl_bytes 	-= PAGE_WRITE_BUFFER_SIZE;

        // Delay
        for(i=0; i < 200000; i++);
	}

    ret_val = SetEEPROMWrite(address, ptr, anzahl_bytes);
    
    // Prüfen ob geschrieben werden konnte
    if(ret_val != TRUE)
    {
        return FALSE; 
    }
       
    //----------------------------------------------------------------------
    //  Lesen der geschriebenen Daten
    
    ptr = (u8_t *)&read_test_daten;
    
    // E2Prom auslesen
    ret_val = GetEEPROMRead(KALIBRIERUNGSWERTE_START_ADDRESS, (u8_t *)ptr, sizeof(read_test_daten));
    
    // Prüfen ob die Daten gelesen werden konnten
    if (ret_val == FALSE)
            return FALSE;
    
    //Prüfung ob die gelesenen Daten, den gesschriebenen entsprechen
    for(i = 0; i < sizeof(write_test_daten); i++)
    {
        // Prüfen ob die Daten identisch sind
        if(read_test_daten[i] != write_test_daten[i])
        {
             return FALSE;
        }
    }
            
    return TRUE;
}
/*******************************************************************************
* ENDE SetEEPromTest
*******************************************************************************/
