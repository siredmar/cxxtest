//*********************************************************************************************
//* Modul: Mathematik_Modul
//* Berechnung von Generator- und Netzwerten
//*
//* Versionen siehe mathematik_modul.c
//*
//*********************************************************************************************

#ifndef MATHEMATIK_MODUL_H
#define MATHEMATIK_MODUL_H

#define MUF

// Datentypen
#define byte	unsigned char
#define sbyte	signed char
#define Int16	signed short
#define Int32	signed int
#define UInt16	unsigned short
#define UInt32	unsigned int

#define FALSE	0
#define TRUE	1

#define DIGUREG_II_FLAG	0
#define MUF_FLAG		1

//CAggou - 20022012
// Defines
//#define US_PER_TICK 500								// Anzahl der µs pro Tick
//#define AD_SIZE_FUER_90_GRAD		(5000/US_PER_TICK + 1) // Groeße des Ringpuffers der AD-Wandlung (10 * 0,5ms = 5ms --> 90° versetzt)
													// + 1 = Index des aktuellen Wert

#define MAX_ARRAY_SIZE_RINGPUFFER       (11)	// maximale Groeße (bei 50Hz gegeben) des Ringpuffers der AD-Wandlung (10 * 0,5ms = 5ms --> 90° versetzt)

//#define MAX_ANZAHL_SIGNALE_GEFILTERT    (2)     // Anzahl der Kanäle die mit dem Filter 2ter Ordnung gefiltert werden
//#define MAX_ANZAHL_SIGNALE_GEFILTERT    (6)     // Anzahl der Kanäle die mit dem Filter 2ter Ordnung gefiltert werden //v.3.3 21.01.2013
//v.3.3 22.01.2013 - Durch MAX_ANZAHL_FILTERINSTANZEN ersetzt und nach filter.h verschoben

#define AD_NULL_PUNKT_MATH_MODUL	AD_NULL_PUNKT // DIGUREGII: AD_NULL_PUNKT wird in system.h definiert
#define ARRAY_ANZAHL_FREQUENZ		2
#define ZEIT_GRAD_1					(float)(20000.0/360.0)  //1 Grad bei 50 Hz/20ms

typedef enum
{
	MESSSYSTEM_3U_3I,
	MESSSYSTEM_1U_1I,
	MESSSYSTEM_3U_1I,
	MESSSYSTEM_3U_2I,
} eMESSSYSTEM;

#define WURZEL3         (1.732F)
#define WURZEL3_DRITTEL (0.57735027F)
#define WURZEL2         (1.414F)
#define PI              (3.14159265F)


// Struktur-Definition
struct BERECHNUNG
{
	// Die Ringpuffer-Werte und ad_last (Index) müssen während der AD-Wandlung befülllt werden
	// Werte für die Berechnung
	byte  ad_last;							 // Zeigt auf den aktuellen Wert im Ringpuffer
    float u1[MAX_ARRAY_SIZE_RINGPUFFER];          // Momentanwerte der Generatorspannung 1
    float u2[MAX_ARRAY_SIZE_RINGPUFFER];          // Momentanwerte der Generatorspannung 2
    float u3[MAX_ARRAY_SIZE_RINGPUFFER];          // Momentanwerte der Generatorspannung 3
    float i1[MAX_ARRAY_SIZE_RINGPUFFER];          // Momentanwerte des Generatorstroms 1
    float i2[MAX_ARRAY_SIZE_RINGPUFFER];          // Momentanwerte des Generatorstroms 2
    float i3[MAX_ARRAY_SIZE_RINGPUFFER];          // Momentanwerte des Generatorstroms 3

	// Für DIGUREG II
	float u_sync1_netz[MAX_ARRAY_SIZE_RINGPUFFER]; // Momentanwert der Netzspannung						
	float u_sync2_gen[MAX_ARRAY_SIZE_RINGPUFFER]; // Momentanwert der Generatorspannung
    
	float ua;								 // Alpha-Komponente der Spannung
	float ub;								 // Beta-Komponente der Spannung
	float ia;								 // Alpha-Komponente des Stroms
	float ib;								 // Beta-Komponente des Stroms

	// Berechnete Werte
	float u_gen_l1_eff;						 // Effektivwert der Spannung 1
	float u_gen_l2_eff;						 // Effektivwert der Spannung 2
	float u_gen_l3_eff;						 // Effektivwert der Spannung 3
	float u_gen_eff;						 // Effektivwert der gesamt Spannung

	float i_gen_l1_eff;						 // Effektivwert des Stromes 1
	float i_gen_l2_eff;						 // Effektivwert des Stromes 2
	float i_gen_l3_eff;						 // Effektivwert des Stromes 3
	float i_gen_eff;						 // Effektivwert des gesamt Stromes

	float p_gen;							 // Wirkleistung
	float q_gen;							 // Blindleistung
	float s_gen;							 // Scheinleistung
	float cosphi_gen;						 // Leistungsfaktor

	float u_sync1_netz_eff;					 // Effektivwert der Netz-Spannung, nur DIGUREG II
	float u_sync2_gen_eff;					 // Effektivwert der Generatorspannung, nur DIGUREG II

	float u1_scheitel_positiv;				 // Positiver Scheitelwert der Spannung U1
	float u2_scheitel_positiv;				 // Positiver Scheitelwert der Spannung U2
	float u3_scheitel_positiv;				 // Positiver Scheitelwert der Spannung U3
	
	float i1_scheitel_positiv;				 // Positiver Scheitelwert der Spannung I1
	float i2_scheitel_positiv;				 // Positiver Scheitelwert der Spannung I2
	float i3_scheitel_positiv;				 // Positiver Scheitelwert der Spannung I3

	float u_gen_scheitel_positiv;			 // Positiver Scheitelwert der Spannung U-Gen
	float i_gen_scheitel_positiv;			 // Positiver Scheitelwert der Spannung I-Gen

	float u_sync1_netz_scheitel_positiv;	 // Positiver Scheitelwert der Spannung USync1
	float u_sync2_gen_scheitel_positiv;		 // Positiver Scheitelwert der Spannung USync2
};

struct ALPHA_BETA 
{
    float       ia;      // alfa-Komponente, Strom
    float       ib;      // beta-Komponente, Strom
    float       ua;      // alfa-Komponente, Spannung
    float       ub;      // beta-Komponente, Spannung
};

// Funktionsprototypen
float GetEffektivWertEinezlStrom(float istwert, float istwert_90_grad);

char SetBerechnungsParameter					(float akt_u1, float akt_u2, float akt_u3, float akt_i1, float akt_i2, float akt_i3, 
												 float u_sync1_netz, float u_sync2_gen);

char SetBerechnungLeistungCosphi				(struct BERECHNUNG *berechnung);
char SetBerechnungFilter						();
char SetBerechnungAlphaBeta						(int messsystem);
char GetBerechnungsParameterAlphaBeta			(struct BERECHNUNG *berechnung);
char SetBerechnungScheitelwerte					(struct BERECHNUNG *berechung);

byte   GetFrequenzErmittlung					(int signal_index, int akt_analog_value);
float  GetFrequenz								(int signal_index);
float  GetTimerInterpolation					(Int32 ad_old,Int32 ad_new);
//float GetFrequenzBerechnung				    (float old_time,float aktuell_time, float zeit_offset);
float  GetFrequenzBerechnung                    (float old_time, float aktuell_time);                    //V1.70
float  GetDeltaPhi								(byte spannung1, byte spannung2);
char   SetTimePerTick							(UInt16 ext_us_per_tick);
char   SetNennFrequenz							(UInt16 ext_nenn_frequenz);

void InitFcompBerechnung(float ta, float f0);
float GetFcompBerechnung (float xq, 
                            //float ta,         //V.3.3
                            //float f0,         //V.3.3
                            float schwelle_skalarprodukt, 
                            char *fcomp_bildung_gestoert, 
                            char *fcomp_schwelle_unterschritten,
                            struct ALPHA_BETA *alpha_beta_fcomp);

//float GetFilter2terOrdnung (float x, float b0, float b1, float b2, float a0, float a1);
//float GetFilter2terOrdnung (float x, float b0, float b1, float b2, float a0, float a1, unsigned char n); // V7.80 ab MUF V.3.1.1
//v.3.3 22.02.2013 nach filter.c verschoben


//20122011
#ifndef MATHEMATIK_MODUL
extern
#endif
struct BERECHNUNG berechnung;


#endif //#ifnef(MATHEMATIK_MODUL_H)
