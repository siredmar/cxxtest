#include "MyComplex.hpp"

MyComplex::MyComplex(double R, double I)
{
    Im = I;
    Re = R;
}

MyComplex::MyComplex(double R)
{
    Im = 0.0f;
    Re = R;
}

MyComplex::MyComplex()
{
    Im = 0.0f;
    Re = 0.0f;
}

MyComplex::MyComplex(const MyComplex &c)
{
    this->Re=c.Re;
    this->Im=c.Im;
}

MyComplex::~MyComplex()
{

}

double MyComplex::GetIm()
{
    return Im;
}

double MyComplex::GetRe()
{
    return Re;
}

void MyComplex::SetIm(double I)
{
    Im = I;
}
void MyComplex::SetRe(double R)
{
    Re = R;
}

MyComplex MyComplex::operator + (MyComplex c)
{
    MyComplex Result;
    Result.Im = Im + c.Im;
    Result.Re = Re + c.Re;
    return Result;
}

MyComplex MyComplex::operator = (MyComplex c)
{
    Re = c.Re;
    Im = c.Im;
    return *this;
}

MyComplex Add(MyComplex a, MyComplex b)
{
    MyComplex Result;
    Result.SetIm(a.GetIm() + b.GetIm());
    Result.SetRe(a.GetRe() + b.GetRe());
    return Result;
}

MyComplex Sub(MyComplex a, MyComplex b)
{
    MyComplex Result;
    Result.SetIm(a.GetIm() - b.GetIm());
    Result.SetRe(a.GetRe() - b.GetRe());
    return Result;
}

MyComplex Mult(MyComplex a, MyComplex b)
{
    MyComplex Result;
    Result.SetRe(b.GetRe()*a.GetRe() - a.GetIm() * b.GetIm());
    Result.SetIm(a.GetRe() * b.GetIm() + a.GetIm()*b.GetRe());
    return Result;
}

//MyComplex Div(MyComplex a, MyComplex b)
//{
//    float div = (b.Re*b.Re) + (b.Im*b.Im);
//    MyComplex Result;
//    Result.Re = (a.Re*b.Re)+(a.Im*b.Im);
//    Result.Re /= div;
//    Result.Im = (a.Im*b.Re)-(a.Re*b.Im);
//    Result.Im /= div;
//    return Result;
//}
